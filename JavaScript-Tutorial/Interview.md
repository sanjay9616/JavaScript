### Table of Contents

| No. | Questions                                                                                                                                                     |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | [What is the difference between Call Apply and Bind](#What-is-the-difference-between-Call-Apply-and-Bind)                                                     |
| 1   | [How do you create your own bind method using either call or apply method](#How-do-you-create-your-own-bind-method-using-either-call-or-apply-method)         |
| 1   | [What is debouncing](#What-is-debouncing)                                                                                                                     |
| 1   | [What is throttling](#What-is-throttling)                                                                                                                     |
| 2   | [What is minimum timeout throttling](#What-is-minimum-timeout-throttling)                                                                                     |
| 1   | [What is Hoisting](#What-is-Hoisting)                                                                                                                         |
| 2   | [What is global execution context](#What-is-global-execution-context)                                                                                         |
| 3   | [What is function execution context](#What-is-function-execution-context)                                                                                     |
| 1   | [What are closures](#What-are-closures)                                                                                                                       |
| 1   | [What is the currying function](#What-is-the-currying-function)                                                                                               |
| 1   | [What is memoization](#What-is-memoization)                                                                                                                   |
| 1   | [What is an event flow](#What-is-an-event-flow)                                                                                                               |
| 2   | [What is event bubbling](#What-is-event-bubbling)                                                                                                             |
| 3   | [What is event capturing](#What-is-event-capturing)                                                                                                           |
| 4   | [What is the use of stopPropagation method](#What-is-the-use-of-stopPropagation-method)                                                                       |
| 5   | [What is an event delegation](#What-is-an-event-delegation)                                                                                                   |
| 6   | [What is call stack](#What-is-call-stack)                                                                                                                     |
| 7   | [What is an event queue](#What-is-an-event-queue)                                                                                                             |
| 8   | [What is an event table](#What-is-an-event-table)                                                                                                             |
| 9   | [What is the use of preventDefault method](#What-is-the-use-of-preventDefault-method)                                                                         |
| 10  | [What are events](#What-are-events)                                                                                                                           |
| 11  | [What are server-sent events](#What-are-server-sent-events)                                                                                                   |
| 12  | [How do you receive server-sent event notifications](#How-do-you-receive-server-sent-event-notifications)                                                     |
| 13  | [How do you check browser support for server-sent events](#How-do-you-check-browser-support-for-server-sent-events)                                           |
| 14  | [What are the events available for server sent events](#What-are-the-events-available-for-server-sent-events)                                                 |
| 15  | [What is the difference between document load and DOMContentLoaded events](#What-is-the-difference-between-document-load-and-DOMContentLoaded-events)         |
| 16  | [What is BOM](#What-is-BOM)                                                                                                                                   |
| 1   | [What are the different ways to deal with Asynchronous Code](#What-are-the-different-ways-to-deal-with-Asynchronous-Code)                                     |
| 1   | [What is a callback function](#What-is-a-callback-function)                                                                                                   |
| 2   | [Why do we need callbacks](#Why-do-we-need-callbacks)                                                                                                         |
| 3   | [What is a callback hell](#What-is-a-callback-hell)                                                                                                           |
| 4   | [What is callback in callback](#What-is-callback-in-callback)                                                                                                 |
| 1   | [What is a promise](#What-is-a-promise)                                                                                                                       |
| 2   | [Why do you need a promise](#Why-do-you-need-a-promise)                                                                                                       |
| 3   | [What are the three states of promise](#What-are-the-three-states-of-promise)                                                                                 |
| 4   | [What are the main rules of promise](#What-are-the-main-rules-of-promise)                                                                                     |
| 5   | [What is promise chaining](#What-is-promise-chaining)                                                                                                         |
| 6   | [What is promise.all](#What-is-promise.all)                                                                                                                   |
| 7   | [What is the purpose of the race method in promise](#What-is-the-purpose-of-the-race-method-in-promise)                                                       |
| 8   | [What are the pros and cons of promises over callbacks](#What-are-the-pros-and-cons-of-promises-over-callbacks)                                               |
| 9   | [What are the differences between promises and observables](#What-are-the-differences-between-promises-and-observables)                                       |
| 10  | [How do you prevent promises swallowing errors](#How-do-you-prevent-promises-swallowing-errors)                                                               |
| 11  | [How do you check an object is a promise or not](#How-do-you-check-an-object-is-a-promise-or-not)                                                             |
| 12  | [What is the easiest way to ignore promise errors](#What-is-the-easiest-way-to-ignore-promise-errors)                                                         |
| 13  | [What are asynchronous thunks](#What-are-asynchronous-thunks)                                                                                                 |
| 1   | [What are lambda or arrow functions](#What-are-lambda-or-arrow-functions)                                                                                     |
| 2   | [What is a first class function](#What-is-a-first-class-function)                                                                                             |
| 3   | [What is a first order function](#What-is-a-first-order-function)                                                                                             |
| 4   | [What is a higher order function](#What-is-a-higher-order-function)                                                                                           |
| 5   | [What is a unary function](#What-is-a-unary-function)                                                                                                         |
| 6   | [What is a pure function](#What-is-a-pure-function)                                                                                                           |
| 7   | [What are the differences between pure and impure functions](#What-are-the-differences-between-pure-and-impure-functions)                                     |
| 8   | [What is IIFE(Immediately Invoked Function Expression)](#What-is-IIFE(Immediately-Invoked-Function-Expression))                                               |
| 9   | [How to invoke an IIFE without any extra brackets](#How-to-invoke-an-IIFE-without-any-extra-brackets)                                                         |
| 10  | [What is a thunk function](#What-is-a-thunk-function)                                                                                                         |
| 11  | [What is an Asynchronous Thunks](#What-is-an-Asynchronous-Thunks)                                                                                             |
| 12  | [What is async function](#What-is-async-function)                                                                                                             |
| 13  | [How to use await outside of async function prior to ES2022](#How-to-use-await-outside-of-async-function-prior-to-ES2022)                                     |
| 14  | [What is an anonymous function](#What-is-an-anonymous-function)                                                                                               |
| 15  | [What are compose and pipe functions](#What-are-compose-and-pipe-functions)                                                                                   |
| 16  | [What is eval](#What-is-eval)                                                                                                                                 |
| 17  | [Is it recommended to use eval](#Is-it-recommended-to-use-eval)                                                                                               |
| 18  | [What is the purpose of EvalError object](#What-is-the-purpose-of-EvalError-object)                                                                           |
| 19  | [What is the purpose of uneval](#What-is-the-purpose-of-uneval)                                                                                               |
| 20  | [What is the difference between uneval and eval](#What-is-the-difference-between-uneval-and-eval)                                                             |
| 21  | [Can we define properties for functions](#Can-we-define-properties-for-functions)                                                                             |
| 22  | [What is the way to find the number of parameters expected by a function](#What-is-the-way-to-find-the-number-of-parameters-expected-by-a-function)           |
| 23  | [What are the function parameter rules](#What-are-the-function-parameter-rules)                                                                               |
| 24  | [What is the difference between a parameter and an argument](#What-is-the-difference-between-a-parameter-and-an-argument)                                     |
| 25  | [What are default parameters](#What-are-default-parameters)                                                                                                   |
| 26  | [What is the output of below function calls](#What-is-the-output-of-below-function-calls)                                                                     |
| 27  | [What is the difference between Function constructor and function declaration](#What-is-the-difference-between-Function-constructor-and-function-declaration) |
| 28  | [What is a Proper Tail Call](#What-is-a-Proper-Tail-Call)                                                                                                     |
| 29  | [How to detect if a function is called as constructor](#How-to-detect-if-a-function-is-called-as-constructor)                                                 |
| 30  | [What are the different kinds of generators](#What-are-the-different-kinds-of-generators)                                                                     |
| 31  | [How do you define instance and non-instance properties](#How-do-you-define-instance-and-non-instance-properties)                                             |
| 32  | [What is pass by value and pass by reference](#What-is-pass-by-value-and-pass-by-reference)                                                                   |
| 33  | [What are hidden classes](#What-are-hidden-classes)                                                                                                           |
| 34  | [What is referential transparency](#What-is-referential-transparency)                                                                                         |
| 35  | [What is module pattern](#What-is-module-pattern)                                                                                                             |
| 36  | [What is Function Composition](#What-is-Function-Composition)                                                                                                 |
| 37  | [What is the purpose of the this keyword in JavaScript](#What-is-the-purpose-of-the-this-keyword-in-JavaScript)                                               |
| 38  | [What Is Obfuscation in javascript](#What-Is-Obfuscation-in-javascript)                                                                                       |
| 39  | [Why do you need Obfuscation](#Why-do-you-need-Obfuscation)                                                                                                   |
| 40  | [What is Minification](#What-is-Minification)                                                                                                                 |
| 41  | [What are the advantages of minification](#What-are-the-advantages-of-minification)                                                                           |
| 42  | [What are the differences between Obfuscation and Encryption](#What-are-the-differences-between-Obfuscation-and-Encryption)                                   |
| 43  | [What are the common tools used for minification](#What-are-the-common-tools-used-for-minification)                                                           |
| 44  | [How do you perform form validation using javascript](#How-do-you-perform-form-validation-using-javascript)                                                   |
| 45  | [How do you perform form validation without javascript](#How-do-you-perform-form-validation-without-javascript)                                               |
| 46  | [What are the DOM methods available for constraint validation](#What-are-the-DOM-methods-available-for-constraint-validation)                                 |
| 47  | [What are the available constraint validation DOM properties](#What-are-the-available-constraint-validation-DOM-properties)                                   |
| 48  | [What are the list of validity properties](#What-are-the-list-of-validity-properties)                                                                         |
| 49  | [Give an example usage of rangeOverflow property](#Give-an-example-usage-of-rangeOverflow-property)                                                           |
| 50  | [What is an enum](#What-is-an-enum)                                                                                                                           |
| 51  | [Is enums feature available in javascript](#Is-enums-feature-available-in-javascript)                                                                         |
| 52  | [How do you extend classes](#How-do-you-extend-classes)                                                                                                       |
| 1   | [What is the use of setTimeout](#What-is-the-use-of-setTimeout)                                                                                               |
| 2   | [What is the purpose of clearTimeout method](#What-is-the-purpose-of-clearTimeout-method)                                                                     |
| 3   | [What is the use of setInterval](#What-is-the-use-of-setInterval)                                                                                             |
| 4   | [What is the purpose of clearInterval method](#What-is-the-purpose-of-clearInterval-method)                                                                   |
| 5   | [What is the difference between setTimeout, setImmediate and process.nextTick](#What-is-the-difference-between-setTimeout,-setImmediate-and-process.nextTick) |
| 6   | [How to cancel a fetch request](#How-to-cancel-a-fetch-request)                                                                                               |
| 7   | [How do you display data in a tabular format using console object](#How-do-you-display-data-in-a-tabular-format-using-console-object)                         |
| 8   | [What are the tools or techniques used for debugging JavaScript code](#What-are-the-tools-or-techniques-used-for-debugging-JavaScript-code)                   |
| 9   | [What is a debugger statement](#What-is-a-debugger-statement)                                                                                                 |
| 10  | [What is the purpose of breakpoints in debugging](#What-is-the-purpose-of-breakpoints-in-debugging)                                                           |
| 11  | [What are the placeholders from console object](#What-are-the-placeholders-from-console-object)                                                               |
| 12  | [Is it possible to add CSS to console messages](#Is-it-possible-to-add-CSS-to-console-messages)                                                               |
| 13  | [What is the purpose of dir method of console object](#What-is-the-purpose-of-dir-method-of-console-object)                                                   |
| 14  | [Is it possible to debug HTML elements in console](#Is-it-possible-to-debug-HTML-elements-in-console)                                                         |
| 15  | [How do you group and nest console output](#How-do-you-group-and-nest-console-output)                                                                         |
| 16  | [How do style the console output using CSS](#How-do-style-the-console-output-using-CSS)                                                                       |
| 17  | [How do you encode an URL](#How-do-you-encode-an-URL)                                                                                                         |
| 18  | [How do you decode an URL](#How-do-you-decode-an-URL)                                                                                                         |
| 19  | [What are the various url properties of location object](#What-are-the-various-url-properties-of-location-object)                                             |
| 20  | [How do you get the current url with javascript](#How-do-you-get-the-current-url-with-javascript)                                                             |
| 21  | [How do I modify the url without reloading the page](#How-do-I-modify-the-url-without-reloading-the-page)                                                     |
| 22  | [How do you decode or encode a URL in JavaScript](#How-do-you-decode-or-encode-a-URL-in-JavaScript)                                                           |
| 23  | [How do get query string values in javascript](#How-do-get-query-string-values-in-javascript)                                                                 |
| 24  | [How do you print the contents of web page](#How-do-you-print-the-contents-of-web-page)                                                                       |
| 25  | [How do you access history in javascript](#How-do-you-access-history-in-javascript)                                                                           |
| 26  | [How do you detect caps lock key turned on or not](#How-do-you-detect-caps-lock-key-turned-on-or-not)                                                         |
| 1   | [What is a service worker](#What-is-a-service-worker)                                                                                                         |
| 2   | [How do you manipulate DOM using a service worker](#How-do-you-manipulate-DOM-using-a-service-worker)                                                         |
| 3   | [How do you reuse information across service worker restarts](#How-do-you-reuse-information-across-service-worker-restarts)                                   |
| 4   | [How do you check web workers browser support](#How-do-you-check-web-workers-browser-support)                                                                 |
| 5   | [Give an example of a web worker](#Give-an-example-of-a-web-worker)                                                                                           |
| 6   | [What are the restrictions of web workers on DOM](#What-are-the-restrictions-of-web-workers-on-DOM)                                                           |
| 1   | [What is a strict mode in javascript](#What-is-a-strict-mode-in-javascript)                                                                                   |
| 2   | [Why do you need strict mode](#Why-do-you-need-strict-mode)                                                                                                   |
| 3   | [How do you declare strict mode](#How-do-you-declare-strict-mode)                                                                                             |
| 4   | [What are the list of cases error thrown from non-strict mode to strict mode](#What-are-the-list-of-cases-error-thrown-from-non-strict-mode-to-strict-mode)   |

### <h2>What is the difference between Call, Apply and Bind</h2>

The difference between Call, Apply and Bind can be explained with below examples,

<h3>Call:</h3>

The call() method invokes a function with a given `this` value and arguments provided one by one.

**Example**

```javascript
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
   console.log(greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2);
}

invite.call(employee1, "Hello", "How are you?"); // Hello John Rodson, How are you?
invite.call(employee2, "Hello", "How are you?"); // Hello Jimmy Baily, How are you?
```

<h3>Apply:</h3>

Invokes the function with a given `this` value and allows you to pass in arguments as an array.

**Example**

```javascript
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
   console.log(greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2);
}

invite.apply(employee1, ["Hello", "How are you?"]); // Hello John Rodson, How are you?
invite.apply(employee2, ["Hello", "How are you?"]); // Hello Jimmy Baily, How are you?
```

<h3>Bind:</h3>

Returns a new function, allowing you to pass any number of arguments.

**Example**

```javascript
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
   console.log(greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2);
}

var inviteEmployee1 = invite.bind(employee1);
var inviteEmployee2 = invite.bind(employee2);
inviteEmployee1("Hello", "How are you?"); // Hello John Rodson, How are you?
inviteEmployee2("Hello", "How are you?"); // Hello Jimmy Baily, How are you?
```

Call and Apply are pretty much interchangeable. Both execute the current function immediately. You need to decide whether it’s easier to send in an array or a comma separated list of arguments. You can remember by treating Call is for **comma** (separated list) and Apply is for **Array**.

Bind creates a new function that will have `this` set to the first parameter passed to bind().

### <h2>How do you create your own bind method using either call or apply method</h2>

The custom bind function needs to be created on Function prototype inorder to use it as other builtin functions. This custom function should return a function similar to original bind method and the implementation of inner function needs to use apply method call.

The function which is going to bind using custom `myOwnBind` method act as the attached function(`boundTargetFunction`) and argument as the object for `apply` method call.

```js
Function.prototype.myOwnBind = function (whoIsCallingMe) {
if (typeof this !== "function") {
    throw new Error(this + "cannot be bound as it's not callable");
}
const boundTargetFunction = this;
return function () {
    boundTargetFunction.apply(whoIsCallingMe, arguments);
};
};
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is debouncing</h2>

Debouncing is a programming pattern that allows delaying execution of some piece of code until a specified time to avoid unnecessary _CPU cycles, API calls and improve performance_. The debounce function make sure that your code is only triggered once per user input. The common usecases are Search box suggestions, text-field auto-saves, and eliminating double-button clicks.

Let's say you want to show suggestions for a search query, but only after a visitor has finished typing it. So here you write a debounce function where the user keeps writing the characters with in 500ms then previous timer cleared out using `clearTimeout` and reschedule API call/DB query for a new time—300 ms in the future.

```js
function debounce(func, timeout = 500) {
let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
        func.apply(this, args);
        }, timeout);
    };
}
function fetchResults() {
    console.log("Fetching input suggestions");
}
const processChange = debounce(() => fetchResults());
```

The _debounce()_ function can be used on input, button and window events

**Input:**

```html
<input type="text" onkeyup="processChange()" />
```

**Button:**

```html
<button onclick="processChange()">Click me</button>
```

**Windows event:**

```html
window.addEventListener("scroll", processChange);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is throttling</h2>

Throttling is a technique used to limit the execution of an event handler function, even when this event triggers continuously due to user actions. The common use cases are browser resizing, window scrolling etc.

The below example creates a throttle function to reduce the number of events for each pixel change and trigger scroll event for each 100ms except for the first event.

```js
const throttle = (func, limit) => {
    let inThrottle;
        return (...args) => {
            if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
            }
        };
    };
    window.addEventListener("scroll", () => {
    throttle(handleScrollAnimation, 100);
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is minimum timeout throttling</h2>

Both browser and NodeJS javascript environments throttles with a minimum delay that is greater than 0ms. That means even though setting a delay of 0ms will not happen instantaneously. </br>
**Browsers:** They have a minimum delay of 4ms. This throttle occurs when successive calls are triggered due to callback nesting(certain depth) or after a certain number of successive intervals. </br>
Note: The older browsers have a minimum delay of 10ms.</br>
**Nodejs:** They have a minimum delay of 1ms. This throttle happens when the delay is larger than 2147483647 or less than 1.
The best example to explain this timeout throttling behavior is the order of below code snippet.

```javascript
function runMeFirst() {
    console.log("My script is initialized");
}
setTimeout(runMeFirst, 0);
console.log("Script loaded");
```

and the output would be in

```cmd
Script loaded
My script is initialized
```

If you don't use `setTimeout`, the order of logs will be sequential.

```javascript
function runMeFirst() {
    console.log("My script is initialized");
}
runMeFirst();
console.log("Script loaded");
```

and the output is,

```cmd
My script is initialized
Script loaded
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is Hoisting</h2>

Hoisting is a JavaScript mechanism where variables, function declarations and classes are moved to the top of their scope before code execution. Remember that JavaScript only hoists declarations, not initialisation.
Let's take a simple example of variable hoisting,

```javascript
console.log(message); //output : undefined
var message = "The variable Has been hoisted";
```

The above code looks like as below to the interpreter,

```javascript
var message;
console.log(message);
message = "The variable Has been hoisted";
```

In the same fashion, function declarations are hoisted too

```javascript
message("Good morning"); //Good morning

function message(name) {
    console.log(name);
}
```

This hoisting makes functions to be safely used in code before they are declared.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is global execution context</h2>

The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i.e, when the file first loads in the browser). All the global code that is not inside a function or object will be executed inside this global execution context. Since JS engine is single threaded there will be only one global environment and there will be only one global execution context.

For example, the below code other than code inside any function or object is executed inside the global execution context.

```javascript
var x = 10;

function A() {
    console.log("Start function A");
    function B() {
        console.log("In function B");
    }
    B();
}
A();

console.log("GlobalContext");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is function execution context</h2>

Whenever a function is invoked, the JavaScript engine creates a different type of Execution Context known as a Function Execution Context (FEC) within the Global Execution Context (GEC) to evaluate and execute the code within that function.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are closures</h2>

A closure is the combination of a function and the lexical environment within which that function was declared. i.e, It is an inner function that has access to the outer or enclosing function’s variables. The closure has three scope chains

1. Own scope where variables defined between its curly brackets
2. Outer function’s variables
3. Global variables

Let's take an example of closure concept,

```javascript
function Welcome(name) {
    var greetingInfo = function (message) {
        console.log(message + " " + name);
    };
    return greetingInfo;
}
var myFunction = Welcome("John");
myFunction("Welcome "); //Output: Welcome John
myFunction("Hello Mr."); //output: Hello Mr.John
```

As per the above code, the inner function(i.e, greetingInfo) has access to the variables in the outer function scope(i.e, Welcome) even after the outer function has returned.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the currying function</h2>

Currying is the process of taking a function with multiple arguments and turning it into a sequence of functions each with only a single argument. Currying is named after a mathematician **Haskell Curry**. By applying currying, an n-ary function turns into a unary function.

Let's take an example of n-ary function and how it turns into a currying function,

```javascript
const multiArgFunction = (a, b, c) => a + b + c;
console.log(multiArgFunction(1, 2, 3)); // 6

const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
curryUnaryFunction(1); // returns a function: b => c =>  1 + b + c
curryUnaryFunction(1)(2); // returns a function: c => 3 + c
curryUnaryFunction(1)(2)(3); // returns the number 6
```

Curried functions are great to improve **code reusability** and **functional composition**.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is memoization</h2>

Memoization is a functional programming technique which attempts to increase a function’s performance by caching its previously computed results. Each time a memoized function is called, its parameters are used to index the cache. If the data is present, then it can be returned, without executing the entire function. Otherwise the function is executed and then the result is added to the cache.
Let's take an example of adding function with memoization,

```javascript
const memoizAddition = () => {
    let cache = {};
    return (value) => {
        if (value in cache) {
            console.log("Fetching from cache");
            return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier. Hence, can only be accessed using the square bracket notation.
        } else {
            console.log("Calculating result");
            let result = value + 20;
            cache[value] = result;
            return result;
        }
    };
};
// returned function from memoizAddition
const addition = memoizAddition();
console.log(addition(20)); //output: 40 calculated
console.log(addition(20)); //output: 40 cached
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event flow</h2>

Event flow is the order in which event is received on the web page. When you click an element that is nested in various other elements, before your click actually reaches its destination, or target element, it must trigger the click event for each of its parent elements first, starting at the top with the global window object.

There are two ways of event flow

1. Top to Bottom(Event Capturing) </h2>
2. Bottom to Top (Event Bubbling)

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is event bubbling</h2>

Event bubbling is a type of event propagation where the event first triggers on the innermost target element, and then successively triggers on the ancestors (parents) of the target element in the same nesting hierarchy till it reaches the outermost DOM element.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is event capturing</h2>

Event capturing is a type of event propagation where the event is first captured by the outermost element, and then successively triggers on the descendants (children) of the target element in the same nesting hierarchy till it reaches the innermost DOM element.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of stopPropagation method</h2>

The stopPropagation method is used to stop the event from bubbling up and capturing up the event chain. For example, the below nested divs with stopPropagation method prevents default event propagation when clicking on nested div(Div1)

```javascript
<p>Click DIV1 Element</p>
<div onclick="secondFunc()">DIV 2
<div onclick="firstFunc(event)">DIV 1</div>
</div>

<script>
function firstFunc(event) {
    alert("DIV 1");
    event.stopPropagation();
}

function secondFunc() {
    alert("DIV 2");
}
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event delegation</h2>

Event delegation is a technique for listening to events where you delegate a parent element as the listener for all of the events that happen inside it.

For example, if you wanted to detect field changes in inside a specific form, you can use event delegation technique,

```javascript
var form = document.querySelector("#registration-form");

// Listen for changes to fields inside the form
form.addEventListener(
    "input",
    function (event) {
        // Log the field that was changed
        console.log(event.target);
    },
    false
);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is call stack</h2>

Call Stack is a data structure for javascript interpreters to keep track of function calls(creates execution context) in the program. It has two major actions,

1. Whenever you call a function for its execution, you are pushing it to the stack. </br>
2. Whenever the execution is completed, the function is popped out of the stack.</br>

Let's take an example and it's state representation in a diagram format

```javascript
function hungry() {
 eatFruits();
}

function eatFruits() {
 return "I'm eating fruits";
}

// Invoke the `hungry` function
hungry();
```

The above code processed in a call stack as below,

1. Add the `hungry()` function to the call stack list and execute the code. </br>
2. Add the `eatFruits()` function to the call stack list and execute the code. </br>
3. Delete the `eatFruits()` function from our call stack list. </br>
4. Delete the `hungry()` function from the call stack list since there are no items anymore. </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event queue</h2>

The event queue follows the queue data structure. It stores async callbacks to be added to the call stack. It is also known as the Callback Queue or Macrotask Queue.

Whenever the call stack receives an async function, it is moved into the Web API. Based on the function, Web API executes it and awaits the result. Once it is finished, it moves the callback into the event queue (the callback of the promise is moved into the microtask queue).

The event loop constantly checks whether or not the call stack is empty. Once the call stack is empty and there is a callback in the event queue, the event loop moves the callback into the call stack. But if there is a callback in the microtask queue as well, it is moved first. The microtask queue has a higher priority than the event queue.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event table</h2>

Event Table is a data structure that stores and keeps track of all the events which will be executed asynchronously like after some time interval or after the resolution of some API requests. i.e Whenever you call a setTimeout function or invoke async operation, it is added to the Event Table.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of preventDefault method</h2>

The preventDefault() method cancels the event if it is cancelable, meaning that the default action or behaviour that belongs to the event will not occur. For example, prevent form submission when clicking on submit button and prevent opening the page URL when clicking on hyperlink are some common use cases.

```javascript
document
.getElementById("link")
.addEventListener("click", function (event) {
    event.preventDefault();
});
```

**Note:** Remember that not all events are cancelable.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are events</h2>

Events are "things" that happen to HTML elements. When JavaScript is used in HTML pages, JavaScript can `react` on these events. Some of the examples of HTML events are,

1. Web page has finished loading </br>
2. Input field was changed </br>
3. Button was clicked

Let's describe the behavior of click event for button element,

```javascript
<!doctype html>
<html>
<head>
  <script>
    function greeting() {
      alert('Hello! Good morning');
    }
  </script>
</head>
<body>
  <button type="button" onclick="greeting()">Click me</button>
</body>
</html>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are server-sent events</h2>

Server-sent events (SSE) is a server push technology enabling a browser to receive automatic updates from a server via HTTP connection without resorting to polling. These are a one way communications channel - events flow from server to client only. This has been used in Facebook/Twitter updates, stock price updates, news feeds etc.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you receive server-sent event notifications</h2>

The EventSource object is used to receive server-sent event notifications. For example, you can receive messages from server as below,

```javascript
if (typeof EventSource !== "undefined") {
    var source = new EventSource("sse_generator.js");
    source.onmessage = function (event) {
    document.getElementById("output").innerHTML += event.data + "<br>";
    };
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you check browser support for server-sent events</h2>

You can perform browser support for server-sent events before using it as below,

```javascript
if (typeof EventSource !== "undefined") {
    // Server-sent events supported. Let's have some code here!
} else {
    // No server-sent events supported
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the events available for server sent events</h2>

Below are the list of events available for server sent events

| Event     | Description                                          |
| --------- | ---------------------------------------------------- |
| onopen    | It is used when a connection to the server is opened |
| onmessage | This event is used when a message is received        |
| onerror   | It happens when an error occurs                      |

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between document load and DOMContentLoaded events</h2>

The `DOMContentLoaded` event is fired when the initial HTML document has been completely loaded and parsed, without waiting for assets(stylesheets, images, and subframes) to finish loading. Whereas The load event is fired when the whole page has loaded, including all dependent resources(stylesheets, images).

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is BOM</h2>

The Browser Object Model (BOM) allows JavaScript to "talk to" the browser. It consists of the objects navigator, history, screen, location and document which are children of the window. The Browser Object Model is not standardized and can change based on different browsers.


**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the different ways to deal with Asynchronous Code</h2>

Below are the list of different ways to deal with Asynchronous code.

1. Callbacks </br>
2. Promises </br>
3. Async/await </br>
4. Third-party libraries such as async.js,bluebird etc

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a callback function</h2>

A callback function is a function passed into another function as an argument. This function is invoked inside the outer function to complete an action.
Let's take a simple example of how to use callback function

```javascript
function callbackFunction(name) {
    console.log("Hello " + name);
}

function outerFunction(callback) {
    let name = prompt("Please enter your name.");
    callback(name);
}

outerFunction(callbackFunction);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do we need callbacks</h2>

The callbacks are needed because javascript is an event driven language. That means instead of waiting for a response javascript will keep executing while listening for other events.
Let's take an example with the first function invoking an API call(simulated by setTimeout) and the next function which logs the message.

```javascript
function firstFunction() {
    // Simulate a code delay
    setTimeout(function () {
    console.log("First function called");
    }, 1000);
}
function secondFunction() {
    console.log("Second function called");
}
firstFunction();
secondFunction();

Output;
// Second function called
// First function called
```

As observed from the output, javascript didn't wait for the response of the first function and the remaining code block got executed. So callbacks are used in a way to make sure that certain code doesn’t execute until the other code finishes execution.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a callback hell</h2>

Callback Hell is an anti-pattern with multiple nested callbacks which makes code hard to read and debug when dealing with asynchronous logic. The callback hell looks like below,

```javascript
async1(function(){
    async2(function(){
        async3(function(){
            async4(function(){
                ....
            });
        });
    });
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is callback in callback</h2>

You can nest one callback inside in another callback to execute the actions sequentially one by one. This is known as callbacks in callbacks.

```javascript
loadScript("/script1.js", function (script) {
    console.log("first script is loaded");

    loadScript("/script2.js", function (script) {
    console.log("second script is loaded");

    loadScript("/script3.js", function (script) {
        console.log("third script is loaded");
        // after all scripts are loaded
    });
    });
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a promise</h2>

The Promise represents the completion of an asynchronous operation. It returns a single value based on the operation being rejected or resolved. There are mainly three stages of the Promise, which are shown below:

**Pending**: It is the initial state of each Promise. It represents that the result has not been computed yet.</br>
**Fulfilled**: It means that the operation has completed.</br>
**Rejected**: It represents a failure that occurs during computation.</br>

The syntax of Promise creation looks like below,


```javascript
const promise = new Promise(function (resolve, reject) {
    // promise description
});
```

The usage of a promise would be as below,

```javascript
const promise = new Promise(
    (resolve) => {
    setTimeout(() => {
        resolve("I'm a Promise!");
    }, 5000);
    },
    (reject) => {}
);

promise.then((value) => console.log(value));
```

### <h2>Why do you need a promise</h2>

Promises are used to handle asynchronous operations. They provide an alternative approach for callbacks by reducing the callback hell and writing the cleaner code.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the three states of promise</h2>

Promises have three states:

1. **Pending:** This is an initial state of the Promise before an operation begins </br>
2. **Fulfilled:** This state indicates that the specified operation was completed. </br>
3. **Rejected:** This state indicates that the operation did not complete. In this case an error value will be thrown.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the main rules of promise</h2>

A promise must follow a specific set of rules:

1. A promise is an object that supplies a standard-compliant `.then()` method </br>
2. A pending promise may transition into either fulfilled or rejected state </br>
3. A fulfilled or rejected promise is settled and it must not transition into any other state. </br>
4. Once a promise is settled, the value must not change.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is promise chaining</h2>

The process of executing a sequence of asynchronous tasks one after another using promises is known as Promise chaining. Let's take an example of promise chaining for calculating the final result,

```javascript
new Promise(function (resolve, reject) {
    setTimeout(() => resolve(1), 1000);
})
    .then(function (result) {
    console.log(result); // 1
    return result * 2;
    })
    .then(function (result) {
    console.log(result); // 2
    return result * 3;
    })
    .then(function (result) {
    console.log(result); // 6
    return result * 4;
    });
```

In the above handlers, the result is passed to the chain of .then() handlers with the below work flow,

1. The initial promise resolves in 1 second,
2. After that `.then` handler is called by logging the result(1) and then return a promise with the value of result \* 2. </br>
3. After that the value passed to the next `.then` handler by logging the result(2) and return a promise with result \* 3. </br>
4. Finally the value passed to the last `.then` handler by logging the result(6) and return a promise with result \* 4. </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is promise.all</h2>

Promise.all is a promise that takes an array of promises as an input (an iterable), and it gets resolved when all the promises get resolved or any one of them gets rejected. For example, the syntax of promise.all method is below,

```javascript
Promise.all([Promise1, Promise2, Promise3]) .then(result) => {   console.log(result) }) .catch(error => console.log(`Error in promises ${error}`))
```

**Note:** Remember that the order of the promises(output the result) is maintained as per input order.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of the race method in promise</h2>

Promise.race() method will return the promise instance which is firstly resolved or rejected. Let's take an example of race() method where promise2 is resolved first

```javascript
var promise1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, "one");
});
var promise2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 100, "two");
});

Promise.race([promise1, promise2]).then(function (value) {
    console.log(value); // "two" // Both promises will resolve, but promise2 is faster
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the pros and cons of promises over callbacks</h2>

Below are the list of pros and cons of promises over callbacks,

**Pros:**

1. It avoids callback hell which is unreadable </br>
2. Easy to write sequential asynchronous code with .then() </br>
3. Easy to write parallel asynchronous code with Promise.all() </br>
4. Solves some of the common problems of callbacks(call the callback too late, too early, many times and swallow errors/exceptions)

**Cons:**

1. It makes little complex code </br>
2. You need to load a polyfill if ES6 is not supported

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between promises and observables</h2>

Some of the major difference in a tabular form

| Promises                                                           | Observables                                                                              |
| ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------- |
| Emits only a single value at a time                                | Emits multiple values over a period of time(stream of values ranging from 0 to multiple) |
| Eager in nature; they are going to be called immediately           | Lazy in nature; they require subscription to be invoked                                  |
| Promise is always asynchronous even though it resolved immediately | Observable can be either synchronous or asynchronous                                     |
| Doesn't provide any operators                                      | Provides operators such as map, forEach, filter, reduce, retry, and retryWhen etc        |
| Cannot be canceled                                                 | Canceled by using unsubscribe() method                                                   |

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you prevent promises swallowing errors</h2>

While using asynchronous code, JavaScript’s ES6 promises can make your life a lot easier without having callback pyramids and error handling on every second line. But Promises have some pitfalls and the biggest one is swallowing errors by default.

Let's say you expect to print an error to the console for all the below cases,

```javascript
Promise.resolve("promised value").then(function () {
throw new Error("error");
});

Promise.reject("error value").catch(function () {
throw new Error("error");
});

new Promise(function (resolve, reject) {
throw new Error("error");
});
```

But there are many modern JavaScript environments that won't print any errors. You can fix this problem in different ways,

1. **Add catch block at the end of each chain:** You can add catch block to the end of each of your promise chains

```javascript
Promise.resolve("promised value")
    .then(function () {
    throw new Error("error");
    })
    .catch(function (error) {
    console.error(error.stack);
    });
```

But it is quite difficult to type for each promise chain and verbose too.

2. **Add done method:** You can replace first solution's then and catch blocks with done method

```javascript
Promise.resolve("promised value").done(function () {
    throw new Error("error");
});
```

Let's say you want to fetch data using HTTP and later perform processing on the resulting data asynchronously. You can write `done` block as below,

```javascript
getDataFromHttp()
    .then(function (result) {
    return processDataAsync(result);
    })
    .done(function (processed) {
    displayData(processed);
    });
```

In future, if the processing library API changed to synchronous then you can remove `done` block as below,

```javascript
getDataFromHttp().then(function (result) {
    return displayData(processDataAsync(result));
});
```

and then you forgot to add `done` block to `then` block leads to silent errors.

3. **Extend ES6 Promises by Bluebird:**
Bluebird extends the ES6 Promises API to avoid the issue in the second solution. This library has a “default” onRejection handler which will print all errors from rejected Promises to stderr. After installation, you can process unhandled rejections

```javascript
Promise.onPossiblyUnhandledRejection(function (error) {
    throw error;
});
```

and discard a rejection, just handle it with an empty catch

```javascript
Promise.reject("error value").catch(function () {});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you check an object is a promise or not</h2>

If you don't know if a value is a promise or not, wrapping the value as `Promise.resolve(value)` which returns a promise

```javascript
function isPromise(object) {
    if (Promise && Promise.resolve) {
        return Promise.resolve(object) == object;
    } else {
        throw "Promise not supported in your environment";
    }
}

var i = 1;
var promise = new Promise(function (resolve, reject) {
resolve();
});

console.log(isPromise(i)); // false
console.log(isPromise(promise)); // true
```

Another way is to check for `.then()` handler type

```javascript
function isPromise(value) {
    return Boolean(value && typeof value.then === "function");
}
var i = 1;
var promise = new Promise(function (resolve, reject) {
    resolve();
});

console.log(isPromise(i)); // false
console.log(isPromise(promise)); // true
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the easiest way to ignore promise errors</h2>

The easiest and safest way to ignore promise errors is void that error. This approach is ESLint friendly too.

```js
await promise.catch((e) => void e);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are asynchronous thunks</h2>

The asynchronous thunks are useful to make network requests. Let's see an example of network requests,

```javascript
function fetchData(fn) {
fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then((response) => response.json())
    .then((json) => fn(json));
}

const asyncThunk = function () {
    return fetchData(function getData(data) {
        console.log(data);
    });
};

asyncThunk();
```

The `getData` function won't be called immediately but it will be invoked only when the data is available from API endpoint. The setTimeout function is also used to make our code asynchronous. The best real time example is redux state management library which uses the asynchronous thunks to delay the actions to dispatch.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are lambda or arrow functions</h2>

`An arrow function is a shorter syntax for a function expression and does not have its own **this, arguments, super, or new.target**. These functions are best suited for non-method functions, and they cannot be used as constructors.`

```js
const addTwo = (a, b) => {
    return a + b;
}
console.log(addTwo(4, 5)) // 9

// ########### OR ########### //

const addTwo = (a, b) => (a + b) // if you use () then don't need return statement
console.log(addTwo(4, 5)) // 9
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a first class function</h2>

In Javascript, functions are first class objects. First-class functions means when functions in that language are treated like any other variable.

For example, in such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable. For example, in the below example, handler functions assigned to a listener

```javascript
const handler = () => console.log("This is a click handler function");
document.addEventListener("click", handler);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a first order function</h2>

A first-order function is a function that doesn’t accept another function as an argument and doesn’t return a function as its return value.

```javascript
const firstOrder = () => console.log("I am a first order function!");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a higher order function</h2>

A higher-order function is a function that accepts another function as an argument or returns a function as a return value or both.

```javascript
const firstOrderFunc = () => console.log("Hello, I am a First order function");
const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
higherOrder(firstOrderFunc);
```
**Example**

```js
firstOrderFunc = (name) => {
	return `Hi!! ${name} `;
}

higherOrder = (greeting, message, name) => {
	console.log(`${greeting(name)} ${message}`);
}

higherOrder(firstOrderFunc, 'Welcome To GeeksForGeeks', 'Geeks'); // Hi!! Geeks  Welcome To GeeksForGeeks
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a unary function</h2>

A unary function (i.e. monadic) is a function that accepts exactly one argument. It stands for a single argument accepted by a function.

Let us take an example of unary function,

```javascript
const unaryFunction = (a) => console.log(a + 10); // Add 10 to the given argument and display the value
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a pure function</h2>

`A Pure Function is a function that always produces the same output for the same input` with multiple calls (out doesn't chaned with multiple calls), without any side effect.

```js
const add = (a, b) => { // Pure Function
    return a + b
}
console.log(add(3, 4)) // 7
console.log(add(3, 4)) // 7
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between pure and impure functions</h2>

**Pure Function:** `A Pure Function is a function that always produces the same output for the same input` with multiple calls (out doesn't chaned with multiple calls), without any side effect.

```js
const add = (a, b) => { // Pure Function
    return a + b
}
console.log(add(3, 4)) // 7
console.log(add(3, 4)) // 7
```

**Impure Function:** `An Impure Function is a function that produces the different output for the same input` with multiple calls (output changed with multiple calls), It has side effect.

```js
let total = 0
const addToTotal = (a, b) => { // Impure Function
    total = a + b + total
    return total
}
console.log(addToTotal(3, 4)) // 7
console.log(addToTotal(3, 4)) // 14
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is IIFE(Immediately Invoked Function Expression)</h2>

Immediately Invoked Function Expressions (IIFE) are JavaScript functions that are executed immediately after they are defined. They are typically used to create a local scope for variables to prevent them from polluting the global scope.

```js
(function abc() {
    console.log('DB Connected')
})();
```
**OR**
```js
(() => {
    console.log('DB Connected')
})();
```
```js
((dbName) => { // with parameter
    console.log(`${dbName} is Connected`)
})('UserDetails');
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to invoke an IIFE without any extra brackets</h2>

Immediately Invoked Function Expressions(IIFE) requires a pair of parenthesis to wrap the function which contains set of statements.

```js
(function (dt) {
    console.log(dt.toLocaleTimeString());
})(new Date());
```

Since both IIFE and void operator discard the result of an expression, you can avoid the extra brackets using `void operator` for IIFE as below,

```js
void (function (dt) {
    console.log(dt.toLocaleTimeString());
})(new Date());
```

**[⬆ Back to Top](#table-of-contents)**


### <h2>What is a thunk function</h2>

A thunk is just a function which delays the evaluation of the value. It doesn’t take any arguments but gives the value whenever you invoke the thunk. i.e, It is used not to execute now but it will be sometime in the future. Let's take a synchronous example,

```javascript
const add = (x, y) => x + y;

const thunk = () => add(2, 3);

thunk(); // 5
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an Asynchronous Thunks</h2>

The asynchronous thunks are useful to make network requests. Let's see an example of network requests,

```javascript
function fetchData(fn) {
    fetch("https://jsonplaceholder.typicode.com/todos/1")
        .then((response) => response.json())
        .then((json) => fn(json));
    }

    const asyncThunk = function () {
    return fetchData(function getData(data) {
        console.log(data);
    });
};

asyncThunk();
```

The `getData` function won't be called immediately but it will be invoked only when the data is available from API endpoint. The setTimeout function is also used to make our code asynchronous. The best real time example is redux state management library which uses the asynchronous thunks to delay the actions to dispatch.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is async function</h2>

An async function is a function declared with the `async` keyword which enables asynchronous, promise-based behavior to be written in a cleaner style by avoiding promise chains. These functions can contain zero or more `await` expressions.

Let's take a below async function example,

```javascript
async function logger() {
let data = await fetch("http://someapi.com/users"); // pause until fetch returns
console.log(data);
}
logger();
```

It is basically syntax sugar over ES2015 promises and generators.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to use await outside of async function prior to ES2022</h2>

Prior to ES2022, if you attempted to use an await outside of an async function resulted in a SyntaxError.

```javascript
await Promise.resolve(console.log("Hello await")); // SyntaxError: await is only valid in async function
```

But you can fix this issue with an alternative IIFE (Immediately Invoked Function Expression) to get access to the feature.

```javascript
(async function () {
    await Promise.resolve(console.log("Hello await")); // Hello await
})();
```

In ES2022, you can write top-level await without writing any hacks.

```javascript
await Promise.resolve(console.log("Hello await")); //Hello await
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an anonymous function</h2>

```javascript
function () { // Synax Error

}
```
`An anonymous function is a function without a name!` Anonymous functions are commonly assigned to a variable name or used as a callback function. The syntax would be as below,

```javascript
function (optionalParameters) {
    //do something
}

const myFunction = function(){ //Anonymous function assigned to a variable
    //do something
};

[1, 2, 3].map(function(element){ //Anonymous function used as a callback function
    //do something
});
```

Let's see the above anonymous function in an example,

```javascript
var x = function (a, b) {
    return a * b;
};
var z = x(5, 10);
console.log(z); // 50
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are compose and pipe functions</h2>

`compose and pipe functions are powerful technique that allows developers to combine multiple functions into a single function`

The "compose" and "pipe" are two techniques commonly used in functional programming to simplify complex operations and make code more readable. They are not native to JavaScript and higher-order functions. the `compose()` applies right to left any number of functions to the output of the previous function.

```js
const addTwo = (a) => a + 2;
const substractThree = (a) => a - 3;
const multiplyByFive = (a) => a * 5;

const res = multiplyByFive(substractThree(addTwo(4)))
console.log(res) // 15

// To get compose order from Right to Left - we need reduceRight
const compose = (...fns) => val => fns.reduceRight((prev, fn) => fn(prev), val)
const composeRes = compose(multiplyByFive, substractThree, addTwo)(4);
console.log(composeRes) // 15

// To get same, but compose function from Left to Right - we need reduce
const compose = (...fns) => val => fns.reduce((prev, fn) => fn(prev), val)
const composeRes = compose(multiplyByFive, substractThree, addTwo)(4);
console.log(composeRes) // 19
```

```js
const addTwo = (a) => a + 2;
const substractThree = (a) => a - 3;
const multiplyByFive = (a) => a * 5;
const divideBy = (a, b) => a / b;

const compose = (...fns) => val => fns.reduce((prev, fn) => fn(prev), val)
pipeRes = compose(multiplyByFive, substractThree, addTwo, x => divideBy(x, 2))(4);
console.log(pipeRes) // 9.5
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is eval</h2>

The eval() function evaluates JavaScript code represented as a string. The string can be a JavaScript expression, variable, statement, or sequence of statements.

```javascript
console.log(eval("1 + 2")); //  3
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is it recommended to use eval</h2>

No, it allows arbitrary code to be run which causes a security problem. As we know that the eval() function is used to run text as code. In most of the cases, it should not be necessary to use it.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of EvalError object</h2>

The EvalError object indicates an error regarding the global `eval()` function. Even though this exception is not thrown by JavaScript anymore, the EvalError object remains for compatibility. The syntax of this expression would be as below,

```javascript
new EvalError([message[, fileName[, lineNumber]]])
```

You can throw EvalError with in try...catch block as below,

```javascript
try {
    throw new EvalError('Eval function error', 'someFile.js', 100);
} catch (e) {
    console.log(e.message, e.name, e.fileName);   
}           // "Eval function error", "EvalError", "someFile.js"
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of uneval</h2>

The uneval() is an inbuilt function which is used to create a string representation of the source code of an Object. It is a top-level function and is not associated with any object. Let's see the below example to know more about it's functionality,

```javascript
var a = 1;
uneval(a); // returns a String containing 1
uneval(function user() {}); // returns "(function user(){})"
```

The `uneval()` function has been deprecated. It is recommended to use `toString()` for functions and `JSON.toStringify()` for other cases.

```javascript
function user() {}
console.log(user.toString()); // returns "(function user(){})"
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between uneval and eval</h2>

The `uneval` function returns the source of a given object; whereas the `eval` function does the opposite, by evaluating that source code in a different memory area. Let's see an example to clarify the difference,

```javascript
var msg = uneval(function greeting() {
    return "Hello, Good morning";
});
var greeting = eval(msg);
greeting(); // returns "Hello, Good morning"
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Can we define properties for functions</h2>

Yes, We can define properties for functions because functions are also objects.

```javascript
fn = function (x) {
    //Function code goes here
};

fn.name = "John";

fn.profile = function (y) {
    //Profile code goes here
};
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the way to find the number of parameters expected by a function</h2>

You can use `function.length` syntax to find the number of parameters expected by a function. Let's take an example of `sum` function to calculate the sum of numbers,

```javascript
function sum(num1, num2, num3, num4) {
    return num1 + num2 + num3 + num4;
}
sum.length; // 4 is the number of parameters expected.
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the function parameter rules</h2>

JavaScript functions follow below rules for parameters,

1. The function definitions do not specify data types for parameters. </br>
2. Do not perform type checking on the passed arguments.</br>
3. Do not check the number of arguments received. </br>
i.e, The below function follows the above rules,

```javascript
function functionName(parameter1, parameter2, parameter3) {
    console.log(parameter1); // 1
}
functionName(1);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between a parameter and an argument</h2>

Parameter is the variable name of a function definition whereas an argument represents the value given to a function when it is invoked. Let's explain this with a simple function

```js
function a(param1, param2) { // parameters
    console.log(param1 + param2)
}
a(1, 2) // arguments
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are default parameters</h2>

In ES5, we need to depend on logical OR operators to handle default values of function parameters. Whereas in ES6, Default function parameters feature allows parameters to be initialized with default values if no value or undefined is passed. Let's compare the behavior with an examples,

```javascript
//ES5
var calculateArea = function (height, width) {
    height = height || 50;
    width = width || 60;

    return width * height;
};
console.log(calculateArea()); //300
```

The default parameters makes the initialization more simpler,

```javascript
//ES6
var calculateArea = function (height = 50, width = 60) {
    return width * height;
};

console.log(calculateArea()); //300
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the output of below function calls</h2>

**Code snippet:**

```javascript
const circle = {
    radius: 20,
    diameter() {
        return this.radius * 2;
    },
    perimeter: () => 2 * Math.PI * this.radius,
};
```

```javascript
console.log(circle.diameter());
console.log(circle.perimeter());
```

**Output:**

The output is 40 and NaN. Remember that diameter is a regular function, whereas the value of perimeter is an arrow function. The `this` keyword of a regular function(i.e, diameter) refers to the surrounding scope which is a class(i.e, Shape object). Whereas this keyword of perimeter function refers to the surrounding scope which is a window object. Since there is no radius property on window objects it returns an undefined value and the multiple of number value returns NaN value.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between Function constructor and function declaration</h2>

The functions which are created with `Function constructor` do not create closures to their creation contexts but they are always created in the global scope. i.e, the function can access its own local variables and global scope variables only. Whereas function declarations can access outer function variables(closures) too.

Let's see this difference with an example,

**Function Constructor:**

```javascript
var a = 100;
function createFunction() {
    var a = 200;
    return new Function("return a;");
}
console.log(createFunction()()); // 100
```

**Function declaration:**

```javascript
var a = 100;
function createFunction() {
    var a = 200;
    return function func() {
        return a;
    };
}
console.log(createFunction()()); // 200
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a Proper Tail Call</h2>

First, we should know about tail call before talking about "Proper Tail Call". A tail call is a subroutine or function call performed as the final action of a calling function. Whereas **Proper tail call(PTC)** is a technique where the program or code will not create additional stack frames for a recursion when the function call is a tail call.

For example, the below classic or head recursion of factorial function relies on stack for each step. Each step need to be processed upto `n * factorial(n - 1)`

```javascript
function factorial(n) {
    if (n === 0) {
        return 1;
    }
return n * factorial(n - 1);
}
console.log(factorial(5)); //120
```

But if you use Tail recursion functions, they keep passing all the necessary data it needs down the recursion without relying on the stack.

```javascript
function factorial(n, acc = 1) {
    if (n === 0) {
        return acc;
    }
    return factorial(n - 1, n * acc);
}
console.log(factorial(5)); //120
```

The above pattern returns the same output as the first one. But the accumulator keeps track of total as an argument without using stack memory on recursive calls.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to detect if a function is called as constructor</h2>

You can use `new.target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call.

1. If a constructor or function invoked using the new operator, new.target returns a reference to the constructor or function. </br>
2. For function calls, new.target is undefined.

```javascript
function Myfunc() {
 if (new.target) {
   console.log("called with new");
 } else {
   console.log("not called with new");
 }
}

new Myfunc(); // called with new
Myfunc(); // not called with new
Myfunc.call({}); // not called with new
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the different kinds of generators</h2>

There are five kinds of generators,

**1. Generator function declaration:**

  ```javascript
  function* myGenFunc() {
    yield 1;
    yield 2;
    yield 3;
  }
  const genObj = myGenFunc();
  ```

**2. Generator function expressions:**

  ```javascript
  const myGenFunc = function* () {
    yield 1;
    yield 2;
    yield 3;
  };
  const genObj = myGenFunc();
  ```

**3. Generator method definitions in object literals:**

  ```javascript
  const myObj = {
    *myGeneratorMethod() {
      yield 1;
      yield 2;
      yield 3;
    },
  };
  const genObj = myObj.myGeneratorMethod();
  ```

**4. Generator method definitions in class:**

  ```javascript
  class MyClass {
    *myGeneratorMethod() {
      yield 1;
      yield 2;
      yield 3;
    }
  }
  const myObject = new MyClass();
  const genObj = myObject.myGeneratorMethod();
  ```

**5. Generator as a computed property:**

  ```javascript
  const SomeObj = {
    *[Symbol.iterator]() {
      yield 1;
      yield 2;
      yield 3;
    },
  };

  console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]
  ```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you define instance and non-instance properties</h2>

The Instance properties must be defined inside of class methods. For example, name and age properties defined inside constructor as below,

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
```

But Static(class) and prototype data properties must be defined outside of the ClassBody declaration. Let's assign the age value for Person class as below,

```javascript
Person.staticAge = 30;
Person.prototype.prototypeAge = 40;
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is pass by value and pass by reference</h2>

Pass-by-value creates a new space in memory and makes a copy of a value. Primitives such as string, number, boolean etc will actually create a new copy. Hence, updating one value doesn't impact the other value. i.e, The values are independent of each other.

```javascript
let a = 5;
let b = a;

b++;
console.log(a, b); //5, 6
```

In the above code snippet, the value of `a` is assigned to `b` and the variable `b` has been incremented. Since there is a new space created for variable `b`, any update on this variable doesn't impact the variable `a`.

Pass by reference doesn't create a new space in memory but the new variable adopts a memory address of an initial variable. Non-primitives such as objects, arrays and functions gets the reference of the initiable variable. i.e, updating one value will impact the other variable - **Mutable**.

```javascript
let user1 = {
    name: "John",
    age: 27,
};
let user2 = user1;
user2.age = 30;

console.log(user1.age, user2.age); // 30, 30
```

In the above code snippet, updating the `age` property of one object will impact the other property due to the same reference.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are hidden classes</h2>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is referential transparency</h2>

An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency. Pure functions are referentially transparent.

```javascript
const add = (x, y) => x + y;
const multiplyBy2 = (x) => x * 2;

//Now add (2, 3) can be replaced by 5.

multiplyBy2(add(2, 3));
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is module pattern</h2>

Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object. JavaScript doesn't have access specifiers similar to other languages(Java, Python, etc) to provide private scope. It uses IIFE (Immediately invoked function expression) to allow for private scopes. i.e., a closure that protect variables and methods.

The module pattern looks like below,

```javascript
(function () {
// Private variables or functions goes here.

return {
    // Return public variables or functions here.
};
})();
```

Let's see an example of a module pattern for an employee with private and public access,

```javascript
const createEmployee = (function () {
// Private
const name = "John";
const department = "Sales";
const getEmployeeName = () => name;
const getDepartmentName = () => department;

// Public
return {
    name,
    department,
    getName: () => getEmployeeName(),
    getDepartment: () => getDepartmentName(),
};
})();

console.log(createEmployee.name);
console.log(createEmployee.department);
console.log(createEmployee.getName());
console.log(createEmployee.getDepartment());
```

**Note:** It mimic the concepts of classes with private variables and methods.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is Function Composition</h2>

 It is an approach where the result of one function is passed on to the next function, which is passed to another until the final function is executed for the final result.

```javascript
//example
const double = (x) => x * 2;
const square = (x) => x * x;

var output1 = double(2);
var output2 = square(output1);
console.log(output2);

var output_final = square(double(2));
console.log(output_final);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of the this keyword in JavaScript</h2>

The `this` keyword in JavaScript is a special variable that is used within a function to refer to the object on which the function is invoked. The value of this depends on how the function is called. It allows functions to access and interact with the object they are bound to.

The this keyword in JavaScript is a reference to the object that owns or invokes the current function. Its value is determined by the calling context.

**Example 1: this in a Global Context**

```javascript
console.log(this);
```

In a global context, this refers to the global object (e.g., window in a browser).

**Example 2: this in a Function**

```javascript
function displayThis() {
  console.log(this);
}

displayThis();
```

In a regular function, this refers to the global object.

**Example 3: this in a Method**

```javascript
const person = {
  name: 'John',
  greet: function() {
    console.log('Hello, ' + this.name);
  }
};

person.greet();
```

In a method, this refers to the object that owns the method (person in the case).

**Example 4: this in an Event Handler**

```javascript
document.getElementById('myButton').addEventListener('click', function() {
  console.log(this);
});
```

In an event handler, this refers to the element that triggered the event (the button in this case).

**[⬆ Back to Top](#table-of-contents)**

### <h2>What Is Obfuscation in javascript</h2>

Obfuscation is the deliberate act of creating obfuscated javascript code(i.e, source or machine code) that is difficult for humans to understand. It is something similar to encryption, but a machine can understand the code and execute it.
Let's see the below function before Obfuscation,

```javascript
function greeting() {
console.log("Hello, welcome to JS world");
}
```

And after the code Obfuscation, it would be appeared as below,

```javascript
eval(
(function (p, a, c, k, e, d) {
    e = function (c) {
    return c;
    };
    if (!"".replace(/^/, String)) {
    while (c--) {
        d[c] = k[c] || c;
    }
    k = [
        function (e) {
        return d[e];
        },
    ];
    e = function () {
        return "\\w+";
    };
    c = 1;
    }
    while (c--) {
    if (k[c]) {
        p = p.replace(new RegExp("\\b" + e(c) + "\\b", "g"), k[c]);
    }
    }
    return p;
})(
    "2 1(){0.3('4, 7 6 5 8')}",
    9,
    9,
    "console|greeting|function|log|Hello|JS|to|welcome|world".split("|"),
    0,
    {}
)
);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do you need Obfuscation</h2>

Below are the few reasons for Obfuscation,

1. The Code size will be reduced. So data transfers between server and client will be fast. </br>
2. It hides the business logic from outside world and protects the code from others </br>
3. Reverse engineering is highly difficult </br>
4. The download time will be reduced </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is Minification</h2>

Minification is the process of removing all unnecessary characters(empty spaces are removed) and variables will be renamed without changing it's functionality. It is also a type of obfuscation .

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the advantages of minification</h2>

Normally it is recommended to use minification for heavy traffic and intensive requirements of resources. It reduces file sizes with below benefits,

1. Decreases loading times of a web page </br>
2. Saves bandwidth usages </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between Obfuscation and Encryption</h2>

Below are the main differences between Obfuscation and Encryption,

| Feature            | Obfuscation                                     | Encryption                                                              |
| ------------------ | ----------------------------------------------- | ----------------------------------------------------------------------- |
| Definition         | Changing the form of any data in any other form | Changing the form of information to an unreadable format by using a key |
| A key to decode    | It can be decoded without any key               | It is required                                                          |
| Target data format | It will be converted to a complex form          | Converted into an unreadable format                                     |

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the common tools used for minification</h2>

There are many online/offline tools to minify the javascript files,

1. Google's Closure Compiler </br>
2. UglifyJS2 </br>
3. jsmin </br>
4. javascript-minifier.com/ </br>
5. prettydiff.com </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you perform form validation using javascript</h2>

JavaScript can be used to perform HTML form validation. For example, if the form field is empty, the function needs to notify, and return false, to prevent the form being submitted.
Lets' perform user login in an html form,

```html
<form name="myForm" onsubmit="return validateForm()" method="post">
User name: <input type="text" name="uname" />
<input type="submit" value="Submit" />
</form>
```

And the validation on user login is below,

```javascript
function validateForm() {
var x = document.forms["myForm"]["uname"].value;
if (x == "") {
    alert("The username shouldn't be empty");
    return false;
}
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you perform form validation without javascript</h2>

You can perform HTML form validation automatically without using javascript. The validation enabled by applying the `required` attribute to prevent form submission when the input is empty.

```html
<form method="post">
<input type="text" name="uname" required />
<input type="submit" value="Submit" />
</form>
```

**Note:** Automatic form validation does not work in Internet Explorer 9 or earlier.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the DOM methods available for constraint validation</h2>

The below DOM methods are available for constraint validation on an invalid input,

1. checkValidity(): It returns true if an input element contains valid data. </br>
2. setCustomValidity(): It is used to set the validationMessage property of an input element. </br>
  Let's take an user login form with DOM validations

```javascript
function myFunction() {
 var userName = document.getElementById("uname");
 if (!userName.checkValidity()) {
   document.getElementById("message").innerHTML =
     userName.validationMessage;
 } else {
   document.getElementById("message").innerHTML =
     "Entered a valid username";
 }
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the available constraint validation DOM properties</h2>

Below are the list of some of the constraint validation DOM properties available,

1. validity: It provides a list of boolean properties related to the validity of an input element. </br>
2. validationMessage: It displays the message when the validity is false. </br>
3. willValidate: It indicates if an input element will be validated or not.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the list of validity properties</h2>

The validity property of an input element provides a set of properties related to the validity of data.

1. customError: It returns true, if a custom validity message is set. </br>
2. patternMismatch: It returns true, if an element's value does not match its pattern attribute. </br>
3. rangeOverflow: It returns true, if an element's value is greater than its max attribute. </br>
4. rangeUnderflow: It returns true, if an element's value is less than its min attribute. </br>
5. stepMismatch: It returns true, if an element's value is invalid according to step attribute. </br>
6. tooLong: It returns true, if an element's value exceeds its maxLength attribute. </br>
7. typeMismatch: It returns true, if an element's value is invalid according to type attribute. </br>
8. valueMissing: It returns true, if an element with a required attribute has no value.
9. valid: It returns true, if an element's value is valid.

**[⬆ Back to Top](#table-of-contents)**

### <h2>Give an example usage of rangeOverflow property</h2>

If an element's value is greater than its max attribute then rangeOverflow property returns true. For example, the below form submission throws an error if the value is more than 100,

```html
<input id="age" type="number" max="100" />
<button onclick="myOverflowFunction()">OK</button>
```

```javascript
function myOverflowFunction() {
    if (document.getElementById("age").validity.rangeOverflow) {
        alert("The mentioned age is not allowed");
    }
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an enum</h2>

An enum is a type restricting variables to one value from a predefined set of constants. JavaScript has no enums but typescript provides built-in enum support.

```javascript
enum Color {
    RED, GREEN, BLUE
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is enums feature available in javascript</h2>

No, javascript does not natively support enums. But there are different kinds of solutions to simulate them even though they may not provide exact equivalents. For example, you can use freeze or seal on object,

```javascript
var DaysEnum = Object.freeze({"monday":1, "tuesday":2, "wednesday":3, ...})
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you extend classes</h2>

The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class. It can be used to subclass custom classes as well as built-in objects. The syntax would be as below,

```javascript
class ChildClass extends ParentClass { ... }
```

Let's take an example of Square subclass from Polygon parent class,

```javascript
class Square extends Rectangle {
    constructor(length) {
        super(length, length);
        this.name = "Square";
    }

    get area() {
        return this.width * this.height;
    }

    set area(value) {
        this.area = value;
    }
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of setTimeout</h2>

The setTimeout() method is used to call a function or evaluate an expression after a specified number of milliseconds. For example, let's log a message after 2 seconds using setTimeout method,

```javascript
setTimeout(function () {
    console.log("Good morning");
}, 2000);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of clearTimeout method</h2>

The clearTimeout() function is used in javascript to clear the timeout which has been set by setTimeout() function before that. i.e, The return value of setTimeout() function is stored in a variable and it’s passed into the clearTimeout() function to clear the timer.

For example, the below setTimeout method is used to display the message after 3 seconds. This timeout can be cleared by the clearTimeout() method.

```javascript
<script>
var msg;
function greeting() {
    alert('Good morning');
}
function start() {
msg =setTimeout(greeting, 3000);

}

function stop() {
    clearTimeout(msg);
}
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of setInterval</h2>

The setInterval() method is used to call a function or evaluate an expression at specified intervals (in milliseconds). For example, let's log a message after 2 seconds using setInterval method,

```javascript
setInterval(function () {
    console.log("Good morning");
}, 2000);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of clearInterval method</h2>

The clearInterval() function is used in javascript to clear the interval which has been set by setInterval() function. i.e, The return value returned by setInterval() function is stored in a variable and it’s passed into the clearInterval() function to clear the interval.

For example, the below setInterval method is used to display the message for every 3 seconds. This interval can be cleared by the clearInterval() method.

```javascript
<script>
var msg;
function greeting() {
    alert('Good morning');
}

function start() {
    msg = setInterval(greeting, 3000);
}

function stop() {
    clearInterval(msg);
}
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between setTimeout, setImmediate and process.nextTick</h2>

1. **Set Timeout:** setTimeout() is to schedule execution of a one-time callback after delay milliseconds. </br>
2. **Set Immediate:** The setImmediate function is used to execute a function right after the current event loop finishes. </br>
3. **Process NextTick:** If process.nextTick() is called in a given phase, all the callbacks passed to process.nextTick() will be resolved before the event loop continues. This will block the event loop and create I/O Starvation if process.nextTick() is called recursively.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to cancel a fetch request</h2>

Until a few days back, One shortcoming of native promises is no direct way to cancel a fetch request. But the new `AbortController` from js specification allows you to use a signal to abort one or multiple fetch calls.
The basic flow of cancelling a fetch request would be as below,

1. Create an `AbortController` instance
2. Get the signal property of an instance and pass the signal as a fetch option for signal
3. Call the AbortController's abort property to cancel all fetches that use that signal
For example, let's pass the same signal to multiple fetch calls will cancel all requests with that signal,

```javascript
const controller = new AbortController();
const { signal } = controller;

fetch("http://localhost:8000", { signal })
.then((response) => {
    console.log(`Request 1 is complete!`);
})
.catch((e) => {
    if (e.name === "AbortError") {
    // We know it's been canceled!
    }
});

fetch("http://localhost:8000", { signal })
.then((response) => {
    console.log(`Request 2 is complete!`);
})
.catch((e) => {
    if (e.name === "AbortError") {
    // We know it's been canceled!
    }
});

// Wait 2 seconds to abort both requests
setTimeout(() => controller.abort(), 2000);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you display data in a tabular format using console object</h2>

The `console.table()` is used to display data in the console in a tabular format to visualize complex arrays or objects.

```js
const users = [
    { name: "John", id: 1, city: "Delhi" },
    { name: "Max", id: 2, city: "London" },
    { name: "Rod", id: 3, city: "Paris" },
];
console.table(users);
```

**Not:** Remember that `console.table()` is not supported in IE.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the tools or techniques used for debugging JavaScript code</h2>

You can use below tools or techniques for debugging javascript

1. Chrome Devtools </br>
2. debugger statement </br>
3. Good old console.log statement </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a debugger statement</h2>

The debugger statement invokes any available debugging functionality, such as setting a breakpoint. If no debugging functionality is available, this statement has no effect.
For example, in the below function a debugger statement has been inserted. So
execution is paused at the debugger statement just like a breakpoint in the script source.

```javascript
function getProfile() {
    // code goes here
    debugger;
    // code goes here
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of breakpoints in debugging</h2>

You can set breakpoints in the javascript code once the debugger statement is executed and the debugger window pops up. At each breakpoint, javascript will stop executing, and let you examine the JavaScript values. After examining values, you can resume the execution of code using the play button.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the placeholders from console object</h2>

Below are the list of placeholders available from console object,

1. %o — It takes an object, </br>
2. %s — It takes a string, </br>
3. %d — It is used for a decimal or integer
  These placeholders can be represented in the console.log as below

```javascript
const user = { name: "John", id: 1, city: "Delhi" };
console.log(
 "Hello %s, your details %o are available in the object form",
 "John",
 user
); // Hello John, your details {name: "John", id: 1, city: "Delhi"} are available in object
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is it possible to add CSS to console messages</h2>

Yes, you can apply CSS styles to console messages similar to html text on the web page.

```javascript
console.log(
"%c The text has blue color, with large font and red background",
"color: blue; font-size: x-large; background: red"
);
```

**Note:** All CSS styles can be applied to console messages.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of dir method of console object</h2>

The `console.dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON.

```javascript
const user = { name: "John", id: 1, city: "Delhi" };
console.dir(user);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is it possible to debug HTML elements in console</h2>

Yes, it is possible to get and debug HTML elements in the console just like inspecting elements.

```javascript
const element = document.getElementsByTagName("body")[0];
console.log(element);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you group and nest console output<h2>

The `console.group()` can be used to group related log messages to be able to easily read the logs and use console.groupEnd()to close the group. Along with this, you can also nest groups which allows to output message in hierarchical manner.

For example, if you’re logging a user’s details:

```js
console.group("User Details");
console.log("name: Sudheer Jonna");
console.log("job: Software Developer");

// Nested Group
console.group("Address");
console.log("Street: Commonwealth");
console.log("City: Los Angeles");
console.log("State: California");

// Close nested group
console.groupEnd();

// Close outer group
console.groupEnd();
```

You can also use `console.groupCollapsed()` instead of `console.group()` if you want the groups to be collapsed by default.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do style the console output using CSS</h2>

You can add CSS styling to the console output using the CSS format content specifier %c. The console string message can be appended after the specifier and CSS style in another argument. Let's print the red the color text using console.log and CSS specifier as below,

```js
console.log("%cThis is a red text", "color:red");
```

It is also possible to add more styles for the content. For example, the font-size can be modified for the above text

```js
console.log(
    "%cThis is a red text with bigger font",
    "color:red; font-size:20px"
);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you encode an URL</h2>

The encodeURI() function is used to encode complete URI which has special characters except (, / ? : @ & = + $ #) characters.

```javascript
var uri = "https://mozilla.org/?x=шеллы";
var encoded = encodeURI(uri);
console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you decode an URL</h2>

The decodeURI() function is used to decode a Uniform Resource Identifier (URI) previously created by encodeURI().

```javascript
var uri = "https://mozilla.org/?x=шеллы";
var encoded = encodeURI(uri);
console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
try {
    console.log(decodeURI(encoded)); // "https://mozilla.org/?x=шеллы"
} catch (e) {
    // catches a malformed URI
    console.error(e);
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the various url properties of location object</h2>

The below `Location` object properties can be used to access URL components of the page,

1. href - The entire URL </h2>
2. protocol - The protocol of the URL </h2>
3. host - The hostname and port of the URL </h2>
4. hostname - The hostname of the URL </h2>
5. port - The port number in the URL </h2>
6. pathname - The path name of the URL </h2>
7. search - The query portion of the URL </h2>
8. hash - The anchor portion of the URL </h2>

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you get the current url with javascript<h2>

You can use `window.location.href` expression to get the current url path and you can use the same expression for updating the URL too. You can also use `document.URL` for read-only purposes but this solution has issues in FF.

```javascript
console.log("location.href", window.location.href); // Returns full URL
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do I modify the url without reloading the page</h2>

The `window.location.href` property will be helpful to modify the url but it reloads the page. HTML5 introduced the `history.pushState()` and `history.replaceState()` methods, which allow you to add and modify history entries, respectively. For example, you can use pushState as below,

```javascript
window.history.pushState("page2", "Title", "/page2.html");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you decode or encode a URL in JavaScript</h2>

`encodeURI()` function is used to encode an URL. This function requires a URL string as a parameter and return that encoded string. </br>
`decodeURI()` function is used to decode an URL. This function requires an encoded URL string as parameter and return that decoded string.

**Note:** If you want to encode characters such as `/ ? : @ & = + $ #` then you need to use `encodeURIComponent()`.

```javascript
let uri = "https://mozilla.org/?x=шеллы";
let encoded_uri = encodeURI(uri); // output - https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
let decoded_uri = decodeURI(encoded_uri); // output - https://mozilla.org/?x=шеллы
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do get query string values in javascript</h2>

You can use URLSearchParams to get query string values in javascript. Let's see an example to get the client code value from URL query string,

```javascript
const urlParams = new URLSearchParams(window.location.search);
const clientCode = urlParams.get("clientCode");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you print the contents of web page</h2>

The window object provided a print() method which is used to print the contents of the current window. It opens a Print dialog box which lets you choose between various printing options. Let's see the usage of print method in an example,

```html
<input type="button" value="Print" onclick="window.print()" />
```

**Note:** In most browsers, it will block while the print dialog is open.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you access history in javascript</h2>

The window.history object contains the browser's history. You can load previous and next URLs in the history using back() and next() methods.

```javascript
function goBack() {
    window.history.back();
}

function goForward() {
    window.history.forward();
}
```

**Note:** You can also access history without window prefix.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you detect caps lock key turned on or not</h2>

The `mouseEvent getModifierState()` is used to return a boolean value that indicates whether the specified modifier key is activated or not. The modifiers such as CapsLock, ScrollLock and NumLock are activated when they are clicked, and deactivated when they are clicked again.

Let's take an input element to detect the CapsLock on/off behavior with an example,

```html
<input type="password" onmousedown="enterInput(event)" />

<p id="feedback"></p>

<script>
    function enterInput(e) {
    var flag = e.getModifierState("CapsLock");
    if (flag) {
        document.getElementById("feedback").innerHTML = "CapsLock activated";
    } else {
        document.getElementById("feedback").innerHTML =
        "CapsLock not activated";
    }
    }
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a service worker</h2>

A Service worker is basically a script (JavaScript file) that runs in the background, separate from a web page and provides features that don't need a web page or user interaction. Some of the major features of service workers are Rich offline experiences(offline first web application development), periodic background syncs, push notifications, intercept and handle network requests and programmatically managing a cache of responses.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you manipulate DOM using a service worker</h2>

Service worker can't access the DOM directly. But it can communicate with the pages it controls by responding to messages sent via the `postMessage` interface, and those pages can manipulate the DOM.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you reuse information across service worker restarts</h2>

The problem with service worker is that it gets terminated when not in use, and restarted when it's next needed, so you cannot rely on global state within a service worker's `onfetch` and `onmessage` handlers. In this case, service workers will have access to IndexedDB API in order to persist and reuse across restarts.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you check web workers browser support</h2>

You need to check browser support for web workers before using it

```javascript
if (typeof Worker !== "undefined") {
    // code for Web worker support.
} else {
    // Sorry! No Web Worker support..
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Give an example of a web worker</h2>

You need to follow below steps to start using web workers for counting example

1. Create a Web Worker File: You need to write a script to increment the count value. Let's name it as counter.js

```javascript
let i = 0;

function timedCount() {
    i = i + 1;
    postMessage(i);
    setTimeout("timedCount()", 500);
}

timedCount();
```

Here postMessage() method is used to post a message back to the HTML page

1. Create a Web Worker Object: You can create a web worker object by checking for browser support. Let's name this file as web_worker_example.js

```javascript
if (typeof w == "undefined") {
    w = new Worker("counter.js");
}
```

and we can receive messages from web worker

```javascript
w.onmessage = function (event) {
    document.getElementById("message").innerHTML = event.data;
};
```

1. Terminate a Web Worker:
    Web workers will continue to listen for messages (even after the external script is finished) until it is terminated. You can use the terminate() method to terminate listening to the messages.

```javascript
w.terminate();
```

1. Reuse the Web Worker: If you set the worker variable to undefined you can reuse the code

```javascript
w = undefined;
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the restrictions of web workers on DOM</h2>

WebWorkers don't have access to below javascript objects since they are defined in an external files

1. Window object </br>
2. Document object </br>
3. Parent object

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a strict mode in javascript</h2>


Strict Mode is a new feature in ECMAScript 5 that allows you to place a program, or a function, in a “strict” operating context. This way it prevents certain actions from being taken and throws more exceptions. The literal expression `"use strict";` instructs the browser to use the javascript code in the Strict mode.

Strict Mode in Javascript is something that I always hear about in various forums but never actually implemented it. Well, I thought this is a good opportunity to do some research on.

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do you need strict mode</h2>

Strict mode is useful to write "secure" JavaScript by notifying "bad syntax" into real errors. For example, it eliminates accidentally creating a global variable by throwing an error and also throws an error for assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you declare strict mode</h2>

The strict mode is declared by adding "use strict"; to the beginning of a script or a function.
If declared at the beginning of a script, it has global scope.

```javascript
"use strict";
x = 3.14; // This will cause an error because x is not declared
```

and if you declare inside a function, it has local scope

```javascript
x = 3.14; // This will not cause an error.
myFunction();

function myFunction() {
    "use strict";
    y = 3.14; // This will cause an error
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the list of cases error thrown from non-strict mode to strict mode</h2>

When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script

1. When you use Octal syntax

```javascript
var n = 022;
```

2. Using `with` statement </br>
3. When you use delete operator on a variable name </br>
4. Using eval or arguments as variable or function argument name </br>
5. When you use newly reserved keywords </br>
6. When you declare a function in a block </br>

```javascript
if (someCondition) {
function f() {}
}
```

Hence, the errors from above cases are helpful to avoid errors in development/production environments.

**[⬆ Back to Top](#table-of-contents)**


<h2><a href="https://github.com/sanjay9616/JavaScript/blob/master/JavaScript-Tutorial/README.md"> 🔙 Back</a></h2>
