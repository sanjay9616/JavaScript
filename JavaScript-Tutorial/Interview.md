### Table of Contents

| No. | Questions                                                                                                                                                     |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | [What is the difference between Call Apply and Bind](#What-is-the-difference-between-Call-Apply-and-Bind)                                                     |
| 1   | [How do you create your own bind method using either call or apply method](#How-do-you-create-your-own-bind-method-using-either-call-or-apply-method)         |
| 1   | [What is debouncing](#What-is-debouncing)                                                                                                                     |
| 1   | [What is throttling](#What-is-throttling)                                                                                                                     |
| 2   | [What is minimum timeout throttling](#What-is-minimum-timeout-throttling)                                                                                     |
| 1   | [What is Hoisting](#What-is-Hoisting)                                                                                                                         |
| 2   | [What is global execution context](#What-is-global-execution-context)                                                                                         |
| 3   | [What is function execution context](#What-is-function-execution-context)                                                                                     |
| 1   | [What are closures](#What-are-closures)                                                                                                                       |
| 1   | [What is the currying function](#What-is-the-currying-function)                                                                                               |
| 1   | [What is memoization](#What-is-memoization)                                                                                                                   |
| 1   | [What is an event flow](#What-is-an-event-flow)                                                                                                               |
| 2   | [What is event bubbling](#What-is-event-bubbling)                                                                                                             |
| 3   | [What is event capturing](#What-is-event-capturing)                                                                                                           |
| 4   | [What is the use of stopPropagation method](#What-is-the-use-of-stopPropagation-method)                                                                       |
| 5   | [What is an event delegation](#What-is-an-event-delegation)                                                                                                   |
| 6   | [What is call stack](#What-is-call-stack)                                                                                                                     |
| 7   | [What is an event queue](#What-is-an-event-queue)                                                                                                             |
| 8   | [What is an event table](#What-is-an-event-table)                                                                                                             |
| 9   | [What is the use of preventDefault method](#What-is-the-use-of-preventDefault-method)                                                                         |
| 10  | [What are events](#What-are-events)                                                                                                                           |
| 11  | [What are server-sent events](#What-are-server-sent-events)                                                                                                   |
| 12  | [How do you receive server-sent event notifications](#How-do-you-receive-server-sent-event-notifications)                                                     |
| 13  | [How do you check browser support for server-sent events](#How-do-you-check-browser-support-for-server-sent-events)                                           |
| 14  | [What are the events available for server sent events](#What-are-the-events-available-for-server-sent-events)                                                 |
| 15  | [What is the difference between document load and DOMContentLoaded events](#What-is-the-difference-between-document-load-and-DOMContentLoaded-events)         |
| 16  | [What is BOM](#What-is-BOM)                                                                                                                                   |
| 1   | [What is web storage](#What-is-web-storage)                                                                                                                   |
| 2   | [How do you access web storage](#How-do-you-access-web-storage)                                                                                               |
| 3   | [Why do you need web storage](#Why-do-you-need-web-storage)                                                                                                   |
| 4   | [How do you check web storage browser support](#How-do-you-check-web-storage-browser-support)                                                                 |
| 5   | [What are the differences between cookie, local storage and session storage](#What-are-the-differences-between-cookie,-local-storage-and-session-storage)     |
| 6   | [What is the main difference between localStorage and sessionStorage](#What-is-the-main-difference-between-localStorage-and-sessionStorage)                   |
| 7   | [What are the methods available on session storage](#What-are-the-methods-available-on-session-storage)                                                       |
| 8   | [What is a storage event and its event handler](#What-is-a-storage-event-and-its-event-handler)                                                               |
| 9   | [What is a Cookie](#What-is-a-Cookie)                                                                                                                         |
| 10  | [Why do you need a Cookie](#Why-do-you-need-a-Cookie)                                                                                                         |
| 11  | [What are the options in a cookie](#What-are-the-options-in-a-cookie)                                                                                         |
| 12  | [How do you delete a cookie](#How-do-you-delete-a-cookie)                                                                                                     |
| 1   | [What are the different ways to deal with Asynchronous Code](#What-are-the-different-ways-to-deal-with-Asynchronous-Code)                                     |
| 1   | [What is a callback function](#What-is-a-callback-function)                                                                                                   |
| 2   | [Why do we need callbacks](#Why-do-we-need-callbacks)                                                                                                         |
| 3   | [What is a callback hell](#What-is-a-callback-hell)                                                                                                           |
| 4   | [What is callback in callback](#What-is-callback-in-callback)                                                                                                 |
| 1   | [What is a promise](#What-is-a-promise)                                                                                                                       |
| 2   | [Why do you need a promise](#Why-do-you-need-a-promise)                                                                                                       |
| 3   | [What are the three states of promise](#What-are-the-three-states-of-promise)                                                                                 |
| 4   | [What are the main rules of promise](#What-are-the-main-rules-of-promise)                                                                                     |
| 5   | [What is promise chaining](#What-is-promise-chaining)                                                                                                         |
| 6   | [What is promise.all](#What-is-promise.all)                                                                                                                   |
| 7   | [What is the purpose of the race method in promise](#What-is-the-purpose-of-the-race-method-in-promise)                                                       |
| 8   | [What are the pros and cons of promises over callbacks](#What-are-the-pros-and-cons-of-promises-over-callbacks)                                               |
| 9   | [What are the differences between promises and observables](#What-are-the-differences-between-promises-and-observables)                                       |
| 10  | [How do you prevent promises swallowing errors](#How-do-you-prevent-promises-swallowing-errors)                                                               |
| 11  | [How do you check an object is a promise or not](#How-do-you-check-an-object-is-a-promise-or-not)                                                             |
| 12  | [What is the easiest way to ignore promise errors](#What-is-the-easiest-way-to-ignore-promise-errors)                                                         |
| 13  | [What are asynchronous thunks](#What-are-asynchronous-thunks)                                                                                                 |
| 1   | [What are lambda or arrow functions](#What-are-lambda-or-arrow-functions)                                                                                     |
| 2   | [What is a first class function](#What-is-a-first-class-function)                                                                                             |
| 3   | [What is a first order function](#What-is-a-first-order-function)                                                                                             |
| 4   | [What is a higher order function](#What-is-a-higher-order-function)                                                                                           |
| 5   | [What is a unary function](#What-is-a-unary-function)                                                                                                         |
| 6   | [What is a pure function](#What-is-a-pure-function)                                                                                                           |
| 7   | [What are the differences between pure and impure functions](#What-are-the-differences-between-pure-and-impure-functions)                                     |
| 8   | [What is IIFE(Immediately Invoked Function Expression)](#What-is-IIFE(Immediately-Invoked-Function-Expression))                                               |
| 9   | [How to invoke an IIFE without any extra brackets](#How-to-invoke-an-IIFE-without-any-extra-brackets)                                                         |
| 10  | [What is a thunk function](#What-is-a-thunk-function)                                                                                                         |
| 11  | [What is an Asynchronous Thunks](#What-is-an-Asynchronous-Thunks)                                                                                             |
| 12  | [What is async function](#What-is-async-function)                                                                                                             |
| 13  | [How to use await outside of async function prior to ES2022](#How-to-use-await-outside-of-async-function-prior-to-ES2022)                                     |
| 14  | [What is an anonymous function](#What-is-an-anonymous-function)                                                                                               |
| 15  | [What are compose and pipe functions](#What-are-compose-and-pipe-functions)                                                                                   |
| 16  | [What is eval](#What-is-eval)                                                                                                                                 |
| 17  | [Is it recommended to use eval](#Is-it-recommended-to-use-eval)                                                                                               |
| 18  | [What is the purpose of EvalError object](#What-is-the-purpose-of-EvalError-object)                                                                           |
| 19  | [What is the purpose of uneval](#What-is-the-purpose-of-uneval)                                                                                               |
| 20  | [What is the difference between uneval and eval](#What-is-the-difference-between-uneval-and-eval)                                                             |
| 21  | [Can we define properties for functions](#Can-we-define-properties-for-functions)                                                                             |
| 22  | [What is the way to find the number of parameters expected by a function](#What-is-the-way-to-find-the-number-of-parameters-expected-by-a-function)           |
| 23  | [What are the function parameter rules](#What-are-the-function-parameter-rules)                                                                               |
| 24  | [What is the difference between a parameter and an argument](#What-is-the-difference-between-a-parameter-and-an-argument)                                     |
| 25  | [What are default parameters](#What-are-default-parameters)                                                                                                   |
| 26  | [What is the output of below function calls](#What-is-the-output-of-below-function-calls)                                                                     |
| 27  | [What is the difference between Function constructor and function declaration](#What-is-the-difference-between-Function-constructor-and-function-declaration) |
| 28  | [What is a Proper Tail Call](#What-is-a-Proper-Tail-Call)                                                                                                     |
| 29  | [How to detect if a function is called as constructor](#How-to-detect-if-a-function-is-called-as-constructor)                                                 |
| 30  | [What are the different kinds of generators](#What-are-the-different-kinds-of-generators)                                                                     |
| 31  | [How do you define instance and non-instance properties](#How-do-you-define-instance-and-non-instance-properties)                                             |
| 32  | [What is pass by value and pass by reference](#What-is-pass-by-value-and-pass-by-reference)                                                                   |
| 33  | [What are hidden classes](#What-are-hidden-classes)                                                                                                           |
| 34  | [What is referential transparency](#What-is-referential-transparency)                                                                                         |
| 35  | [What is module pattern](#What-is-module-pattern)                                                                                                             |
| 36  | [What is Function Composition](#What-is-Function-Composition)                                                                                                 |
| 37  | [What is the purpose of the this keyword in JavaScript](#What-is-the-purpose-of-the-this-keyword-in-JavaScript)                                               |
| 38  | [What Is Obfuscation in javascript](#What-Is-Obfuscation-in-javascript)                                                                                       |
| 39  | [Why do you need Obfuscation](#Why-do-you-need-Obfuscation)                                                                                                   |
| 40  | [What is Minification](#What-is-Minification)                                                                                                                 |
| 41  | [What are the advantages of minification](#What-are-the-advantages-of-minification)                                                                           |
| 42  | [What are the differences between Obfuscation and Encryption](#What-are-the-differences-between-Obfuscation-and-Encryption)                                   |
| 43  | [What are the common tools used for minification](#What-are-the-common-tools-used-for-minification)                                                           |
| 44  | [How do you perform form validation using javascript](#How-do-you-perform-form-validation-using-javascript)                                                   |
| 45  | [How do you perform form validation without javascript](#How-do-you-perform-form-validation-without-javascript)                                               |
| 46  | [What are the DOM methods available for constraint validation](#What-are-the-DOM-methods-available-for-constraint-validation)                                 |
| 47  | [What are the available constraint validation DOM properties](#What-are-the-available-constraint-validation-DOM-properties)                                   |
| 48  | [What are the list of validity properties](#What-are-the-list-of-validity-properties)                                                                         |
| 49  | [Give an example usage of rangeOverflow property](#Give-an-example-usage-of-rangeOverflow-property)                                                           |
| 50  | [What is an enum](#What-is-an-enum)                                                                                                                           |
| 51  | [Is enums feature available in javascript](#Is-enums-feature-available-in-javascript)                                                                         |
| 52  | [How do you extend classes](#How-do-you-extend-classes)                                                                                                       |
| 1   | [What is the use of setTimeout](#What-is-the-use-of-setTimeout)                                                                                               |
| 2   | [What is the purpose of clearTimeout method](#What-is-the-purpose-of-clearTimeout-method)                                                                     |
| 3   | [What is the use of setInterval](#What-is-the-use-of-setInterval)                                                                                             |
| 4   | [What is the purpose of clearInterval method](#What-is-the-purpose-of-clearInterval-method)                                                                   |
| 5   | [What is the difference between setTimeout, setImmediate and process.nextTick](#What-is-the-difference-between-setTimeout,-setImmediate-and-process.nextTick) |
| 6   | [How to cancel a fetch request](#How-to-cancel-a-fetch-request)                                                                                               |
| 7   | [How do you display data in a tabular format using console object](#How-do-you-display-data-in-a-tabular-format-using-console-object)                         |
| 8   | [What are the tools or techniques used for debugging JavaScript code](#What-are-the-tools-or-techniques-used-for-debugging-JavaScript-code)                   |
| 9   | [What is a debugger statement](#What-is-a-debugger-statement)                                                                                                 |
| 10  | [What is the purpose of breakpoints in debugging](#What-is-the-purpose-of-breakpoints-in-debugging)                                                           |
| 11  | [What are the placeholders from console object](#What-are-the-placeholders-from-console-object)                                                               |
| 12  | [Is it possible to add CSS to console messages](#Is-it-possible-to-add-CSS-to-console-messages)                                                               |
| 13  | [What is the purpose of dir method of console object](#What-is-the-purpose-of-dir-method-of-console-object)                                                   |
| 14  | [Is it possible to debug HTML elements in console](#Is-it-possible-to-debug-HTML-elements-in-console)                                                         |
| 15  | [How do you group and nest console output](#How-do-you-group-and-nest-console-output)                                                                         |
| 16  | [How do style the console output using CSS](#How-do-style-the-console-output-using-CSS)                                                                       |
| 17  | [How do you encode an URL](#How-do-you-encode-an-URL)                                                                                                         |
| 18  | [How do you decode an URL](#How-do-you-decode-an-URL)                                                                                                         |
| 19  | [What are the various url properties of location object](#What-are-the-various-url-properties-of-location-object)                                             |
| 20  | [How do you get the current url with javascript](#How-do-you-get-the-current-url-with-javascript)                                                             |
| 21  | [How do I modify the url without reloading the page](#How-do-I-modify-the-url-without-reloading-the-page)                                                     |
| 22  | [How do you decode or encode a URL in JavaScript](#How-do-you-decode-or-encode-a-URL-in-JavaScript)                                                           |
| 23  | [How do get query string values in javascript](#How-do-get-query-string-values-in-javascript)                                                                 |
| 24  | [How do you print the contents of web page](#How-do-you-print-the-contents-of-web-page)                                                                       |
| 25  | [How do you access history in javascript](#How-do-you-access-history-in-javascript)                                                                           |
| 26  | [How do you detect caps lock key turned on or not](#How-do-you-detect-caps-lock-key-turned-on-or-not)                                                         |
| 1   | [What is a service worker](#What-is-a-service-worker)                                                                                                         |
| 2   | [How do you manipulate DOM using a service worker](#How-do-you-manipulate-DOM-using-a-service-worker)                                                         |
| 3   | [How do you reuse information across service worker restarts](#How-do-you-reuse-information-across-service-worker-restarts)                                   |
| 4   | [How do you check web workers browser support](#How-do-you-check-web-workers-browser-support)                                                                 |
| 5   | [Give an example of a web worker](#Give-an-example-of-a-web-worker)                                                                                           |
| 6   | [What are the restrictions of web workers on DOM](#What-are-the-restrictions-of-web-workers-on-DOM)                                                           |
| 1   | [What is a strict mode in javascript](#What-is-a-strict-mode-in-javascript)                                                                                   |
| 2   | [Why do you need strict mode](#Why-do-you-need-strict-mode)                                                                                                   |
| 3   | [How do you declare strict mode](#How-do-you-declare-strict-mode)                                                                                             |
| 4   | [What are the list of cases error thrown from non-strict mode to strict mode](#What-are-the-list-of-cases-error-thrown-from-non-strict-mode-to-strict-mode)   |
| 1   | [How to verify if a variable is an array](#How-to-verify-if-a-variable-is-an-array)                                                                           |
| 2   | [Is const variable makes the value immutable](#Is-const-variable-makes-the-value-immutable)                                                                   |
| 3   | [What is the precedence order between local and global variables](#What-is-the-precedence-order-between-local-and-global-variables)                           |
| 4   | [How do you assign default values to variables](#How-do-you-assign-default-values-to-variables)                                                               |
| 5   | [What are the benefits of keeping declarations at the top](#What-are-the-benefits-of-keeping-declarations-at-the-top)                                         |
| 6   | [What is the purpose of the let keyword](#What-is-the-purpose-of-the-let-keyword)                                                                             |
| 7   | [What is the reason to choose the name let as a keyword](#What-is-the-reason-to-choose-the-name-let-as-a-keyword)                                             |
| 8   | [Can I redeclare let and const variables](#Can-I-redeclare-let-and-const-variables)                                                                           |
| 9   | [What are global variables](#What-are-global-variables)                                                                                                       |
| 10  | [What are the problems with global variables](#What-are-the-problems-with-global-variables)                                                                   |
| 1   | [How do you redeclare variables in switch block without an error](#How-do-you-redeclare-variables-in-switch-block-without-an-error)                           |
| 2   | [What are the pros and cons of for loop](#What-are-the-pros-and-cons-of-for-loop)                                                                             |
| 3   | [What are break and continue statements](#What-are-break-and-continue-statements)                                                                             |
| 4   | [What are js labels](#What-are-js-labels)                                                                                                                     |
| 5   | [What are the conventions to be followed for the usage of switch case](#What-are-the-conventions-to-be-followed-for-the-usage-of-switch-case)                 |
| 6   | [What is the purpose of switch-case](#What-is-the-purpose-of-switch-case)                                                                                     |
| 7   | [What are the two types of loops in javascript](#What-are-the-two-types-of-loops-in-javascript)                                                               |
| 8   | [What is an empty statement and purpose of it](#What-is-an-empty-statement-and-purpose-of-it)                                                                 |
| 9   | [What is an event loop](#What-is-an-event-loop)                                                                                                               |
| 10  | [How do you create an infinite loop](#How-do-you-create-an-infinite-loop)                                                                                     |
| 11  | [Why do you need to avoid with statement](#Why-do-you-need-to-avoid-with-statement)                                                                           |
| 12  | [What is the output of below for loops](#What-is-the-output-of-below-for-loops)                                                                               |
| 13  | [What is for...of statement](#What-is-for...of-statement)                                                                                                     |
| 14  | [What are tasks in event loop](#What-are-tasks-in-event-loop)                                                                                                 |
| 15  | [What are different event loops](#What-are-different-event-loops)                                                                                             |
| 16  | [What are the differences between for...of and for...in statements](#What-are-the-differences-between-for...of-and-for...in-statements)                       |
| 1   | [What is the purpose of double exclamation](#What-is-the-purpose-of-double-exclamation)                                                                       |
| 2   | [What is a comma operator and their Advantagess](#What-is-a-comma-operator-and-their-Advantagess)                                                             |
| 3   | [Is the '!--' notation represents a special operator](#Is-the-'!--'-notation-represents-a-special-operator)                                                   |
| 4   | [What is the purpose of double tilde operator](#What-is-the-purpose-of-double-tilde-operator)                                                                 |
| 5   | [What is nullish coalescing operator (??)?](#What-is-nullish-coalescing-operator-(??)?)                                                                       |
| 6   | [What is a conditional operator in javascript](#What-is-a-conditional-operator-in-javascript)                                                                 |
| 7   | [Can you apply chaining on conditional operator](#Can-you-apply-chaining-on-conditional-operator)                                                             |
| 8   | [What is the purpose of the delete operator](#What-is-the-purpose-of-the-delete-operator)                                                                     |
| 9   | [What is typeof operator](#What-is-typeof-operator)                                                                                                           |
| 10  | [What is a void operator](#What-is-a-void-operator)                                                                                                           |
| 11  | [What is an Unary operator](#What-is-an-Unary-operator)                                                                                                       |
| 12  | [What is the output of below console statement with unary operator](#What-is-the-output-of-below-console-statement-with-unary-operator)                       |
| 13  | [How do you create self string using special characters](#How-do-you-create-self-string-using-special-characters)                                             |
| 14  | [What is the output of prepend additive operator on falsy values](#What-is-the-output-of-prepend-additive-operator-on-falsy-values)                           |
| 15  | [What is a Spread operator](#What-is-a-Spread-operator)                                                                                                       |
| 16  | [What is a Rest operator](#What-is-a-Rest-operator)                                                                                                           |
| 17  | [What is the output of below spread operator array](#What-is-the-output-of-below-spread-operator-array)                                                       |
| 18  | [What are the differences between spread operator and rest parameter](#What-are-the-differences-between-spread-operator-and-rest-parameter)                   |
| 19  | [What are the differences between arguments object and rest parameter](#What-are-the-differences-between-arguments-object-and-rest-parameter)                 |
| 20  | [What happens if you do not use rest parameter as a last argument](#What-happens-if-you-do-not-use-rest-parameter-as-a-last-argument)                         |
| 21  | [What are the bitwise operators available in javascript](#What-are-the-bitwise-operators-available-in-javascript)                                             |
| 22  | [What are various operators supported by javascript](#What-are-various-operators-supported-by-javascript)                                                     |
| 23  | [What is destructuring aliases](#What-is-destructuring-aliases)                                                                                               |
| 24  | [What is destructuring assignment](#What-is-destructuring-assignment)                                                                                         |
| 25  | [What are default values in destructuring assignment](#What-are-default-values-in-destructuring-assignment)                                                   |
| 26  | [How do you swap variables in destructuring assignment](#How-do-you-swap-variables-in-destructuring-assignment)                                               |


### <h2>What is the difference between Call, Apply and Bind</h2>

The difference between Call, Apply and Bind can be explained with below examples,

<h3>Call:</h3>

The call() method invokes a function with a given `this` value and arguments provided one by one.

**Example**

```javascript
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
   console.log(greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2);
}

invite.call(employee1, "Hello", "How are you?"); // Hello John Rodson, How are you?
invite.call(employee2, "Hello", "How are you?"); // Hello Jimmy Baily, How are you?
```

<h3>Apply:</h3>

Invokes the function with a given `this` value and allows you to pass in arguments as an array.

**Example**

```javascript
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
   console.log(greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2);
}

invite.apply(employee1, ["Hello", "How are you?"]); // Hello John Rodson, How are you?
invite.apply(employee2, ["Hello", "How are you?"]); // Hello Jimmy Baily, How are you?
```

<h3>Bind:</h3>

Returns a new function, allowing you to pass any number of arguments.

**Example**

```javascript
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
   console.log(greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2);
}

var inviteEmployee1 = invite.bind(employee1);
var inviteEmployee2 = invite.bind(employee2);
inviteEmployee1("Hello", "How are you?"); // Hello John Rodson, How are you?
inviteEmployee2("Hello", "How are you?"); // Hello Jimmy Baily, How are you?
```

Call and Apply are pretty much interchangeable. Both execute the current function immediately. You need to decide whether it’s easier to send in an array or a comma separated list of arguments. You can remember by treating Call is for **comma** (separated list) and Apply is for **Array**.

Bind creates a new function that will have `this` set to the first parameter passed to bind().

### <h2>How do you create your own bind method using either call or apply method</h2>

The custom bind function needs to be created on Function prototype inorder to use it as other builtin functions. This custom function should return a function similar to original bind method and the implementation of inner function needs to use apply method call.

The function which is going to bind using custom `myOwnBind` method act as the attached function(`boundTargetFunction`) and argument as the object for `apply` method call.

```js
Function.prototype.myOwnBind = function (whoIsCallingMe) {
if (typeof this !== "function") {
    throw new Error(this + "cannot be bound as it's not callable");
}
const boundTargetFunction = this;
return function () {
    boundTargetFunction.apply(whoIsCallingMe, arguments);
};
};
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is debouncing</h2>

Debouncing is a programming pattern that allows delaying execution of some piece of code until a specified time to avoid unnecessary _CPU cycles, API calls and improve performance_. The debounce function make sure that your code is only triggered once per user input. The common usecases are Search box suggestions, text-field auto-saves, and eliminating double-button clicks.

Let's say you want to show suggestions for a search query, but only after a visitor has finished typing it. So here you write a debounce function where the user keeps writing the characters with in 500ms then previous timer cleared out using `clearTimeout` and reschedule API call/DB query for a new time—300 ms in the future.

```js
function debounce(func, timeout = 500) {
let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
        func.apply(this, args);
        }, timeout);
    };
}
function fetchResults() {
    console.log("Fetching input suggestions");
}
const processChange = debounce(() => fetchResults());
```

The _debounce()_ function can be used on input, button and window events

**Input:**

```html
<input type="text" onkeyup="processChange()" />
```

**Button:**

```html
<button onclick="processChange()">Click me</button>
```

**Windows event:**

```html
window.addEventListener("scroll", processChange);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is throttling</h2>

Throttling is a technique used to limit the execution of an event handler function, even when this event triggers continuously due to user actions. The common use cases are browser resizing, window scrolling etc.

The below example creates a throttle function to reduce the number of events for each pixel change and trigger scroll event for each 100ms except for the first event.

```js
const throttle = (func, limit) => {
    let inThrottle;
        return (...args) => {
            if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
            }
        };
    };
    window.addEventListener("scroll", () => {
    throttle(handleScrollAnimation, 100);
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is minimum timeout throttling</h2>

Both browser and NodeJS javascript environments throttles with a minimum delay that is greater than 0ms. That means even though setting a delay of 0ms will not happen instantaneously. </br>
**Browsers:** They have a minimum delay of 4ms. This throttle occurs when successive calls are triggered due to callback nesting(certain depth) or after a certain number of successive intervals. </br>
Note: The older browsers have a minimum delay of 10ms.</br>
**Nodejs:** They have a minimum delay of 1ms. This throttle happens when the delay is larger than 2147483647 or less than 1.
The best example to explain this timeout throttling behavior is the order of below code snippet.

```javascript
function runMeFirst() {
    console.log("My script is initialized");
}
setTimeout(runMeFirst, 0);
console.log("Script loaded");
```

and the output would be in

```cmd
Script loaded
My script is initialized
```

If you don't use `setTimeout`, the order of logs will be sequential.

```javascript
function runMeFirst() {
    console.log("My script is initialized");
}
runMeFirst();
console.log("Script loaded");
```

and the output is,

```cmd
My script is initialized
Script loaded
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is Hoisting</h2>

Hoisting is a JavaScript mechanism where variables, function declarations and classes are moved to the top of their scope before code execution. Remember that JavaScript only hoists declarations, not initialisation.
Let's take a simple example of variable hoisting,

```javascript
console.log(message); //output : undefined
var message = "The variable Has been hoisted";
```

The above code looks like as below to the interpreter,

```javascript
var message;
console.log(message);
message = "The variable Has been hoisted";
```

In the same fashion, function declarations are hoisted too

```javascript
message("Good morning"); //Good morning

function message(name) {
    console.log(name);
}
```

This hoisting makes functions to be safely used in code before they are declared.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is global execution context</h2>

The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i.e, when the file first loads in the browser). All the global code that is not inside a function or object will be executed inside this global execution context. Since JS engine is single threaded there will be only one global environment and there will be only one global execution context.

For example, the below code other than code inside any function or object is executed inside the global execution context.

```javascript
var x = 10;

function A() {
    console.log("Start function A");
    function B() {
        console.log("In function B");
    }
    B();
}
A();

console.log("GlobalContext");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is function execution context</h2>

Whenever a function is invoked, the JavaScript engine creates a different type of Execution Context known as a Function Execution Context (FEC) within the Global Execution Context (GEC) to evaluate and execute the code within that function.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are closures</h2>

A closure is the combination of a function and the lexical environment within which that function was declared. i.e, It is an inner function that has access to the outer or enclosing function’s variables. The closure has three scope chains

1. Own scope where variables defined between its curly brackets
2. Outer function’s variables
3. Global variables

Let's take an example of closure concept,

```javascript
function Welcome(name) {
    var greetingInfo = function (message) {
        console.log(message + " " + name);
    };
    return greetingInfo;
}
var myFunction = Welcome("John");
myFunction("Welcome "); //Output: Welcome John
myFunction("Hello Mr."); //output: Hello Mr.John
```

As per the above code, the inner function(i.e, greetingInfo) has access to the variables in the outer function scope(i.e, Welcome) even after the outer function has returned.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the currying function</h2>

Currying is the process of taking a function with multiple arguments and turning it into a sequence of functions each with only a single argument. Currying is named after a mathematician **Haskell Curry**. By applying currying, an n-ary function turns into a unary function.

Let's take an example of n-ary function and how it turns into a currying function,

```javascript
const multiArgFunction = (a, b, c) => a + b + c;
console.log(multiArgFunction(1, 2, 3)); // 6

const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
curryUnaryFunction(1); // returns a function: b => c =>  1 + b + c
curryUnaryFunction(1)(2); // returns a function: c => 3 + c
curryUnaryFunction(1)(2)(3); // returns the number 6
```

Curried functions are great to improve **code reusability** and **functional composition**.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is memoization</h2>

Memoization is a functional programming technique which attempts to increase a function’s performance by caching its previously computed results. Each time a memoized function is called, its parameters are used to index the cache. If the data is present, then it can be returned, without executing the entire function. Otherwise the function is executed and then the result is added to the cache.
Let's take an example of adding function with memoization,

```javascript
const memoizAddition = () => {
    let cache = {};
    return (value) => {
        if (value in cache) {
            console.log("Fetching from cache");
            return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier. Hence, can only be accessed using the square bracket notation.
        } else {
            console.log("Calculating result");
            let result = value + 20;
            cache[value] = result;
            return result;
        }
    };
};
// returned function from memoizAddition
const addition = memoizAddition();
console.log(addition(20)); //output: 40 calculated
console.log(addition(20)); //output: 40 cached
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event flow</h2>

Event flow is the order in which event is received on the web page. When you click an element that is nested in various other elements, before your click actually reaches its destination, or target element, it must trigger the click event for each of its parent elements first, starting at the top with the global window object.

There are two ways of event flow

1. Top to Bottom(Event Capturing) </h2>
2. Bottom to Top (Event Bubbling)

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is event bubbling</h2>

Event bubbling is a type of event propagation where the event first triggers on the innermost target element, and then successively triggers on the ancestors (parents) of the target element in the same nesting hierarchy till it reaches the outermost DOM element.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is event capturing</h2>

Event capturing is a type of event propagation where the event is first captured by the outermost element, and then successively triggers on the descendants (children) of the target element in the same nesting hierarchy till it reaches the innermost DOM element.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of stopPropagation method</h2>

The stopPropagation method is used to stop the event from bubbling up and capturing up the event chain. For example, the below nested divs with stopPropagation method prevents default event propagation when clicking on nested div(Div1)

```javascript
<p>Click DIV1 Element</p>
<div onclick="secondFunc()">DIV 2
<div onclick="firstFunc(event)">DIV 1</div>
</div>

<script>
function firstFunc(event) {
    alert("DIV 1");
    event.stopPropagation();
}

function secondFunc() {
    alert("DIV 2");
}
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event delegation</h2>

Event delegation is a technique for listening to events where you delegate a parent element as the listener for all of the events that happen inside it.

For example, if you wanted to detect field changes in inside a specific form, you can use event delegation technique,

```javascript
var form = document.querySelector("#registration-form");

// Listen for changes to fields inside the form
form.addEventListener(
    "input",
    function (event) {
        // Log the field that was changed
        console.log(event.target);
    },
    false
);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is call stack</h2>

Call Stack is a data structure for javascript interpreters to keep track of function calls(creates execution context) in the program. It has two major actions,

1. Whenever you call a function for its execution, you are pushing it to the stack. </br>
2. Whenever the execution is completed, the function is popped out of the stack.</br>

Let's take an example and it's state representation in a diagram format

```javascript
function hungry() {
 eatFruits();
}

function eatFruits() {
 return "I'm eating fruits";
}

// Invoke the `hungry` function
hungry();
```

The above code processed in a call stack as below,

1. Add the `hungry()` function to the call stack list and execute the code. </br>
2. Add the `eatFruits()` function to the call stack list and execute the code. </br>
3. Delete the `eatFruits()` function from our call stack list. </br>
4. Delete the `hungry()` function from the call stack list since there are no items anymore. </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event queue</h2>

The event queue follows the queue data structure. It stores async callbacks to be added to the call stack. It is also known as the Callback Queue or Macrotask Queue.

Whenever the call stack receives an async function, it is moved into the Web API. Based on the function, Web API executes it and awaits the result. Once it is finished, it moves the callback into the event queue (the callback of the promise is moved into the microtask queue).

The event loop constantly checks whether or not the call stack is empty. Once the call stack is empty and there is a callback in the event queue, the event loop moves the callback into the call stack. But if there is a callback in the microtask queue as well, it is moved first. The microtask queue has a higher priority than the event queue.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event table</h2>

Event Table is a data structure that stores and keeps track of all the events which will be executed asynchronously like after some time interval or after the resolution of some API requests. i.e Whenever you call a setTimeout function or invoke async operation, it is added to the Event Table.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of preventDefault method</h2>

The preventDefault() method cancels the event if it is cancelable, meaning that the default action or behaviour that belongs to the event will not occur. For example, prevent form submission when clicking on submit button and prevent opening the page URL when clicking on hyperlink are some common use cases.

```javascript
document
.getElementById("link")
.addEventListener("click", function (event) {
    event.preventDefault();
});
```

**Note:** Remember that not all events are cancelable.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are events</h2>

Events are "things" that happen to HTML elements. When JavaScript is used in HTML pages, JavaScript can `react` on these events. Some of the examples of HTML events are,

1. Web page has finished loading </br>
2. Input field was changed </br>
3. Button was clicked

Let's describe the behavior of click event for button element,

```javascript
<!doctype html>
<html>
<head>
  <script>
    function greeting() {
      alert('Hello! Good morning');
    }
  </script>
</head>
<body>
  <button type="button" onclick="greeting()">Click me</button>
</body>
</html>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are server-sent events</h2>

Server-sent events (SSE) is a server push technology enabling a browser to receive automatic updates from a server via HTTP connection without resorting to polling. These are a one way communications channel - events flow from server to client only. This has been used in Facebook/Twitter updates, stock price updates, news feeds etc.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you receive server-sent event notifications</h2>

The EventSource object is used to receive server-sent event notifications. For example, you can receive messages from server as below,

```javascript
if (typeof EventSource !== "undefined") {
    var source = new EventSource("sse_generator.js");
    source.onmessage = function (event) {
    document.getElementById("output").innerHTML += event.data + "<br>";
    };
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you check browser support for server-sent events</h2>

You can perform browser support for server-sent events before using it as below,

```javascript
if (typeof EventSource !== "undefined") {
    // Server-sent events supported. Let's have some code here!
} else {
    // No server-sent events supported
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the events available for server sent events</h2>

Below are the list of events available for server sent events

| Event     | Description                                          |
| --------- | ---------------------------------------------------- |
| onopen    | It is used when a connection to the server is opened |
| onmessage | This event is used when a message is received        |
| onerror   | It happens when an error occurs                      |

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between document load and DOMContentLoaded events</h2>

The `DOMContentLoaded` event is fired when the initial HTML document has been completely loaded and parsed, without waiting for assets(stylesheets, images, and subframes) to finish loading. Whereas The load event is fired when the whole page has loaded, including all dependent resources(stylesheets, images).

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is BOM</h2>

The Browser Object Model (BOM) allows JavaScript to "talk to" the browser. It consists of the objects navigator, history, screen, location and document which are children of the window. The Browser Object Model is not standardized and can change based on different browsers.


**[⬆ Back to Top](#table-of-contents)**

### <h2>What is web storage</h2>

Web storage is an API that provides a mechanism by which browsers can store key/value pairs locally within the user's browser, in a much more intuitive fashion than using cookies. The web storage provides two mechanisms for storing data on the client.

1. **Local storage:** It stores data for current origin with no expiration date. </br>
2. **Session storage:** It stores data for one session and the data is lost when the browser tab is closed.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you access web storage</h2>

The Window object implements the `WindowLocalStorage` and `WindowSessionStorage` objects which has `localStorage`(window.localStorage) and `sessionStorage`(window.sessionStorage) properties respectively. These properties create an instance of the Storage object, through which data items can be set, retrieved and removed for a specific domain and storage type (session or local).
For example, you can read and write on local storage objects as below

```javascript
localStorage.setItem("logo", document.getElementById("logo").value);
localStorage.getItem("logo");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do you need web storage</h2>

Web storage is more secure, and large amounts of data can be stored locally, without affecting website performance. Also, the information is never transferred to the server. Hence this is a more recommended approach than Cookies.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you check web storage browser support</h2>

You need to check browser support for localStorage and sessionStorage before using web storage,

```javascript
if (typeof Storage !== "undefined") {
    // Code for localStorage/sessionStorage.
} else {
    // Sorry! No Web Storage support..
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between cookie, local storage and session storage</h2>

Below are some of the differences between cookie, local storage and session storage,

| Feature                           | Cookie                             | Local storage    | Session storage     |
| --------------------------------- | ---------------------------------- | ---------------- | ------------------- |
| Accessed on client or server side | Both server-side & client-side     | client-side only | client-side only    |
| Lifetime                          | As configured using Expires option | until deleted    | until tab is closed |
| SSL support                       | Supported                          | Not supported    | Not supported       |
| Maximum data size                 | 4KB                                | 5 MB             | 5MB                 |

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the main difference between localStorage and sessionStorage</h2>

LocalStorage is the same as SessionStorage but it persists the data even when the browser is closed and reopened(i.e it has no expiration time) whereas in sessionStorage data gets cleared when the page session ends.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the methods available on session storage</h2>

The session storage provided methods for reading, writing and clearing the session data

```javascript
// Save data to sessionStorage
sessionStorage.setItem("key", "value");

// Get saved data from sessionStorage
let data = sessionStorage.getItem("key");

// Remove saved data from sessionStorage
sessionStorage.removeItem("key");

// Remove all saved data from sessionStorage
sessionStorage.clear();
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a storage event and its event handler</h2>

The StorageEvent is an event that fires when a storage area has been changed in the context of another document. Whereas onstorage property is an EventHandler for processing storage events.
The syntax would be as below

```javascript
window.onstorage = functionRef;
```

Let's take the example usage of onstorage event handler which logs the storage key and it's values

```javascript
window.onstorage = function (e) {
    console.log(
    "The " +
        e.key +
        " key has been changed from " +
        e.oldValue +
        " to " +
        e.newValue +
        "."
    );
};
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a Cookie</h2>

A cookie is a piece of data that is stored on your computer to be accessed by your browser. Cookies are saved as key/value pairs.
For example, you can create a cookie named username as below,

```javascript
document.cookie = "username=John";
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do you need a Cookie</h2>

Cookies are used to remember information about the user profile(such as username). It basically involves two steps,

1. When a user visits a web page, the user profile can be stored in a cookie. </br>
2. Next time the user visits the page, the cookie remembers the user profile.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the options in a cookie</h2>

There are few below options available for a cookie,

1. By default, the cookie is deleted when the browser is closed but you can change this behavior by setting expiry date (in UTC time).

```javascript
document.cookie = "username=John; expires=Sat, 8 Jun 2019 12:00:00 UTC";
```

1. By default, the cookie belongs to a current page. But you can tell the browser what path the cookie belongs to using a path parameter.

```javascript
document.cookie = "username=John; path=/services";
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you delete a cookie</h2>

You can delete a cookie by setting the expiry date as a passed date. You don't need to specify a cookie value in this case.
For example, you can delete a username cookie in the current page as below.

```javascript
document.cookie =
"username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";
```

**Note:** You should define the cookie path option to ensure that you delete the right cookie. Some browsers doesn't allow to delete a cookie unless you specify a path parameter.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the different ways to deal with Asynchronous Code</h2>

Below are the list of different ways to deal with Asynchronous code.

1. Callbacks </br>
2. Promises </br>
3. Async/await </br>
4. Third-party libraries such as async.js,bluebird etc

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a callback function</h2>

A callback function is a function passed into another function as an argument. This function is invoked inside the outer function to complete an action.
Let's take a simple example of how to use callback function

```javascript
function callbackFunction(name) {
    console.log("Hello " + name);
}

function outerFunction(callback) {
    let name = prompt("Please enter your name.");
    callback(name);
}

outerFunction(callbackFunction);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do we need callbacks</h2>

The callbacks are needed because javascript is an event driven language. That means instead of waiting for a response javascript will keep executing while listening for other events.
Let's take an example with the first function invoking an API call(simulated by setTimeout) and the next function which logs the message.

```javascript
function firstFunction() {
    // Simulate a code delay
    setTimeout(function () {
    console.log("First function called");
    }, 1000);
}
function secondFunction() {
    console.log("Second function called");
}
firstFunction();
secondFunction();

Output;
// Second function called
// First function called
```

As observed from the output, javascript didn't wait for the response of the first function and the remaining code block got executed. So callbacks are used in a way to make sure that certain code doesn’t execute until the other code finishes execution.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a callback hell</h2>

Callback Hell is an anti-pattern with multiple nested callbacks which makes code hard to read and debug when dealing with asynchronous logic. The callback hell looks like below,

```javascript
async1(function(){
    async2(function(){
        async3(function(){
            async4(function(){
                ....
            });
        });
    });
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is callback in callback</h2>

You can nest one callback inside in another callback to execute the actions sequentially one by one. This is known as callbacks in callbacks.

```javascript
loadScript("/script1.js", function (script) {
    console.log("first script is loaded");

    loadScript("/script2.js", function (script) {
    console.log("second script is loaded");

    loadScript("/script3.js", function (script) {
        console.log("third script is loaded");
        // after all scripts are loaded
    });
    });
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a promise</h2>

The Promise represents the completion of an asynchronous operation. It returns a single value based on the operation being rejected or resolved. There are mainly three stages of the Promise, which are shown below:

**Pending**: It is the initial state of each Promise. It represents that the result has not been computed yet.</br>
**Fulfilled**: It means that the operation has completed.</br>
**Rejected**: It represents a failure that occurs during computation.</br>

The syntax of Promise creation looks like below,


```javascript
const promise = new Promise(function (resolve, reject) {
    // promise description
});
```

The usage of a promise would be as below,

```javascript
const promise = new Promise(
    (resolve) => {
    setTimeout(() => {
        resolve("I'm a Promise!");
    }, 5000);
    },
    (reject) => {}
);

promise.then((value) => console.log(value));
```

### <h2>Why do you need a promise</h2>

Promises are used to handle asynchronous operations. They provide an alternative approach for callbacks by reducing the callback hell and writing the cleaner code.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the three states of promise</h2>

Promises have three states:

1. **Pending:** This is an initial state of the Promise before an operation begins </br>
2. **Fulfilled:** This state indicates that the specified operation was completed. </br>
3. **Rejected:** This state indicates that the operation did not complete. In this case an error value will be thrown.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the main rules of promise</h2>

A promise must follow a specific set of rules:

1. A promise is an object that supplies a standard-compliant `.then()` method </br>
2. A pending promise may transition into either fulfilled or rejected state </br>
3. A fulfilled or rejected promise is settled and it must not transition into any other state. </br>
4. Once a promise is settled, the value must not change.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is promise chaining</h2>

The process of executing a sequence of asynchronous tasks one after another using promises is known as Promise chaining. Let's take an example of promise chaining for calculating the final result,

```javascript
new Promise(function (resolve, reject) {
    setTimeout(() => resolve(1), 1000);
})
    .then(function (result) {
    console.log(result); // 1
    return result * 2;
    })
    .then(function (result) {
    console.log(result); // 2
    return result * 3;
    })
    .then(function (result) {
    console.log(result); // 6
    return result * 4;
    });
```

In the above handlers, the result is passed to the chain of .then() handlers with the below work flow,

1. The initial promise resolves in 1 second,
2. After that `.then` handler is called by logging the result(1) and then return a promise with the value of result \* 2. </br>
3. After that the value passed to the next `.then` handler by logging the result(2) and return a promise with result \* 3. </br>
4. Finally the value passed to the last `.then` handler by logging the result(6) and return a promise with result \* 4. </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is promise.all</h2>

Promise.all is a promise that takes an array of promises as an input (an iterable), and it gets resolved when all the promises get resolved or any one of them gets rejected. For example, the syntax of promise.all method is below,

```javascript
Promise.all([Promise1, Promise2, Promise3]) .then(result) => {   console.log(result) }) .catch(error => console.log(`Error in promises ${error}`))
```

**Note:** Remember that the order of the promises(output the result) is maintained as per input order.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of the race method in promise</h2>

Promise.race() method will return the promise instance which is firstly resolved or rejected. Let's take an example of race() method where promise2 is resolved first

```javascript
var promise1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, "one");
});
var promise2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 100, "two");
});

Promise.race([promise1, promise2]).then(function (value) {
    console.log(value); // "two" // Both promises will resolve, but promise2 is faster
});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the pros and cons of promises over callbacks</h2>

Below are the list of pros and cons of promises over callbacks,

**Pros:**

1. It avoids callback hell which is unreadable </br>
2. Easy to write sequential asynchronous code with .then() </br>
3. Easy to write parallel asynchronous code with Promise.all() </br>
4. Solves some of the common problems of callbacks(call the callback too late, too early, many times and swallow errors/exceptions)

**Cons:**

1. It makes little complex code </br>
2. You need to load a polyfill if ES6 is not supported

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between promises and observables</h2>

Some of the major difference in a tabular form

| Promises                                                           | Observables                                                                              |
| ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------- |
| Emits only a single value at a time                                | Emits multiple values over a period of time(stream of values ranging from 0 to multiple) |
| Eager in nature; they are going to be called immediately           | Lazy in nature; they require subscription to be invoked                                  |
| Promise is always asynchronous even though it resolved immediately | Observable can be either synchronous or asynchronous                                     |
| Doesn't provide any operators                                      | Provides operators such as map, forEach, filter, reduce, retry, and retryWhen etc        |
| Cannot be canceled                                                 | Canceled by using unsubscribe() method                                                   |

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you prevent promises swallowing errors</h2>

While using asynchronous code, JavaScript’s ES6 promises can make your life a lot easier without having callback pyramids and error handling on every second line. But Promises have some pitfalls and the biggest one is swallowing errors by default.

Let's say you expect to print an error to the console for all the below cases,

```javascript
Promise.resolve("promised value").then(function () {
throw new Error("error");
});

Promise.reject("error value").catch(function () {
throw new Error("error");
});

new Promise(function (resolve, reject) {
throw new Error("error");
});
```

But there are many modern JavaScript environments that won't print any errors. You can fix this problem in different ways,

1. **Add catch block at the end of each chain:** You can add catch block to the end of each of your promise chains

```javascript
Promise.resolve("promised value")
    .then(function () {
    throw new Error("error");
    })
    .catch(function (error) {
    console.error(error.stack);
    });
```

But it is quite difficult to type for each promise chain and verbose too.

2. **Add done method:** You can replace first solution's then and catch blocks with done method

```javascript
Promise.resolve("promised value").done(function () {
    throw new Error("error");
});
```

Let's say you want to fetch data using HTTP and later perform processing on the resulting data asynchronously. You can write `done` block as below,

```javascript
getDataFromHttp()
    .then(function (result) {
    return processDataAsync(result);
    })
    .done(function (processed) {
    displayData(processed);
    });
```

In future, if the processing library API changed to synchronous then you can remove `done` block as below,

```javascript
getDataFromHttp().then(function (result) {
    return displayData(processDataAsync(result));
});
```

and then you forgot to add `done` block to `then` block leads to silent errors.

3. **Extend ES6 Promises by Bluebird:**
Bluebird extends the ES6 Promises API to avoid the issue in the second solution. This library has a “default” onRejection handler which will print all errors from rejected Promises to stderr. After installation, you can process unhandled rejections

```javascript
Promise.onPossiblyUnhandledRejection(function (error) {
    throw error;
});
```

and discard a rejection, just handle it with an empty catch

```javascript
Promise.reject("error value").catch(function () {});
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you check an object is a promise or not</h2>

If you don't know if a value is a promise or not, wrapping the value as `Promise.resolve(value)` which returns a promise

```javascript
function isPromise(object) {
    if (Promise && Promise.resolve) {
        return Promise.resolve(object) == object;
    } else {
        throw "Promise not supported in your environment";
    }
}

var i = 1;
var promise = new Promise(function (resolve, reject) {
resolve();
});

console.log(isPromise(i)); // false
console.log(isPromise(promise)); // true
```

Another way is to check for `.then()` handler type

```javascript
function isPromise(value) {
    return Boolean(value && typeof value.then === "function");
}
var i = 1;
var promise = new Promise(function (resolve, reject) {
    resolve();
});

console.log(isPromise(i)); // false
console.log(isPromise(promise)); // true
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the easiest way to ignore promise errors</h2>

The easiest and safest way to ignore promise errors is void that error. This approach is ESLint friendly too.

```js
await promise.catch((e) => void e);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are asynchronous thunks</h2>

The asynchronous thunks are useful to make network requests. Let's see an example of network requests,

```javascript
function fetchData(fn) {
fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then((response) => response.json())
    .then((json) => fn(json));
}

const asyncThunk = function () {
    return fetchData(function getData(data) {
        console.log(data);
    });
};

asyncThunk();
```

The `getData` function won't be called immediately but it will be invoked only when the data is available from API endpoint. The setTimeout function is also used to make our code asynchronous. The best real time example is redux state management library which uses the asynchronous thunks to delay the actions to dispatch.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are lambda or arrow functions</h2>

`An arrow function is a shorter syntax for a function expression and does not have its own **this, arguments, super, or new.target**. These functions are best suited for non-method functions, and they cannot be used as constructors.`

```js
const addTwo = (a, b) => {
    return a + b;
}
console.log(addTwo(4, 5)) // 9

// ########### OR ########### //

const addTwo = (a, b) => (a + b) // if you use () then don't need return statement
console.log(addTwo(4, 5)) // 9
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a first class function</h2>

In Javascript, functions are first class objects. First-class functions means when functions in that language are treated like any other variable.

For example, in such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable. For example, in the below example, handler functions assigned to a listener

```javascript
const handler = () => console.log("This is a click handler function");
document.addEventListener("click", handler);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a first order function</h2>

A first-order function is a function that doesn’t accept another function as an argument and doesn’t return a function as its return value.

```javascript
const firstOrder = () => console.log("I am a first order function!");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a higher order function</h2>

A higher-order function is a function that accepts another function as an argument or returns a function as a return value or both.

```javascript
const firstOrderFunc = () => console.log("Hello, I am a First order function");
const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
higherOrder(firstOrderFunc);
```
**Example**

```js
firstOrderFunc = (name) => {
	return `Hi!! ${name} `;
}

higherOrder = (greeting, message, name) => {
	console.log(`${greeting(name)} ${message}`);
}

higherOrder(firstOrderFunc, 'Welcome To GeeksForGeeks', 'Geeks'); // Hi!! Geeks  Welcome To GeeksForGeeks
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a unary function</h2>

A unary function (i.e. monadic) is a function that accepts exactly one argument. It stands for a single argument accepted by a function.

Let us take an example of unary function,

```javascript
const unaryFunction = (a) => console.log(a + 10); // Add 10 to the given argument and display the value
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a pure function</h2>

`A Pure Function is a function that always produces the same output for the same input` with multiple calls (out doesn't chaned with multiple calls), without any side effect.

```js
const add = (a, b) => { // Pure Function
    return a + b
}
console.log(add(3, 4)) // 7
console.log(add(3, 4)) // 7
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between pure and impure functions</h2>

**Pure Function:** `A Pure Function is a function that always produces the same output for the same input` with multiple calls (out doesn't chaned with multiple calls), without any side effect.

```js
const add = (a, b) => { // Pure Function
    return a + b
}
console.log(add(3, 4)) // 7
console.log(add(3, 4)) // 7
```

**Impure Function:** `An Impure Function is a function that produces the different output for the same input` with multiple calls (output changed with multiple calls), It has side effect.

```js
let total = 0
const addToTotal = (a, b) => { // Impure Function
    total = a + b + total
    return total
}
console.log(addToTotal(3, 4)) // 7
console.log(addToTotal(3, 4)) // 14
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is IIFE(Immediately Invoked Function Expression)</h2>

Immediately Invoked Function Expressions (IIFE) are JavaScript functions that are executed immediately after they are defined. They are typically used to create a local scope for variables to prevent them from polluting the global scope.

```js
(function abc() {
    console.log('DB Connected')
})();
```
**OR**
```js
(() => {
    console.log('DB Connected')
})();
```
```js
((dbName) => { // with parameter
    console.log(`${dbName} is Connected`)
})('UserDetails');
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to invoke an IIFE without any extra brackets</h2>

Immediately Invoked Function Expressions(IIFE) requires a pair of parenthesis to wrap the function which contains set of statements.

```js
(function (dt) {
    console.log(dt.toLocaleTimeString());
})(new Date());
```

Since both IIFE and void operator discard the result of an expression, you can avoid the extra brackets using `void operator` for IIFE as below,

```js
void (function (dt) {
    console.log(dt.toLocaleTimeString());
})(new Date());
```

**[⬆ Back to Top](#table-of-contents)**


### <h2>What is a thunk function</h2>

A thunk is just a function which delays the evaluation of the value. It doesn’t take any arguments but gives the value whenever you invoke the thunk. i.e, It is used not to execute now but it will be sometime in the future. Let's take a synchronous example,

```javascript
const add = (x, y) => x + y;

const thunk = () => add(2, 3);

thunk(); // 5
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an Asynchronous Thunks</h2>

The asynchronous thunks are useful to make network requests. Let's see an example of network requests,

```javascript
function fetchData(fn) {
    fetch("https://jsonplaceholder.typicode.com/todos/1")
        .then((response) => response.json())
        .then((json) => fn(json));
    }

    const asyncThunk = function () {
    return fetchData(function getData(data) {
        console.log(data);
    });
};

asyncThunk();
```

The `getData` function won't be called immediately but it will be invoked only when the data is available from API endpoint. The setTimeout function is also used to make our code asynchronous. The best real time example is redux state management library which uses the asynchronous thunks to delay the actions to dispatch.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is async function</h2>

An async function is a function declared with the `async` keyword which enables asynchronous, promise-based behavior to be written in a cleaner style by avoiding promise chains. These functions can contain zero or more `await` expressions.

Let's take a below async function example,

```javascript
async function logger() {
let data = await fetch("http://someapi.com/users"); // pause until fetch returns
console.log(data);
}
logger();
```

It is basically syntax sugar over ES2015 promises and generators.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to use await outside of async function prior to ES2022</h2>

Prior to ES2022, if you attempted to use an await outside of an async function resulted in a SyntaxError.

```javascript
await Promise.resolve(console.log("Hello await")); // SyntaxError: await is only valid in async function
```

But you can fix this issue with an alternative IIFE (Immediately Invoked Function Expression) to get access to the feature.

```javascript
(async function () {
    await Promise.resolve(console.log("Hello await")); // Hello await
})();
```

In ES2022, you can write top-level await without writing any hacks.

```javascript
await Promise.resolve(console.log("Hello await")); //Hello await
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an anonymous function</h2>

```javascript
function () { // Synax Error

}
```
`An anonymous function is a function without a name!` Anonymous functions are commonly assigned to a variable name or used as a callback function. The syntax would be as below,

```javascript
function (optionalParameters) {
    //do something
}

const myFunction = function(){ //Anonymous function assigned to a variable
    //do something
};

[1, 2, 3].map(function(element){ //Anonymous function used as a callback function
    //do something
});
```

Let's see the above anonymous function in an example,

```javascript
var x = function (a, b) {
    return a * b;
};
var z = x(5, 10);
console.log(z); // 50
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are compose and pipe functions</h2>

`compose and pipe functions are powerful technique that allows developers to combine multiple functions into a single function`

The "compose" and "pipe" are two techniques commonly used in functional programming to simplify complex operations and make code more readable. They are not native to JavaScript and higher-order functions. the `compose()` applies right to left any number of functions to the output of the previous function.

```js
const addTwo = (a) => a + 2;
const substractThree = (a) => a - 3;
const multiplyByFive = (a) => a * 5;

const res = multiplyByFive(substractThree(addTwo(4)))
console.log(res) // 15

// To get compose order from Right to Left - we need reduceRight
const compose = (...fns) => val => fns.reduceRight((prev, fn) => fn(prev), val)
const composeRes = compose(multiplyByFive, substractThree, addTwo)(4);
console.log(composeRes) // 15

// To get same, but compose function from Left to Right - we need reduce
const compose = (...fns) => val => fns.reduce((prev, fn) => fn(prev), val)
const composeRes = compose(multiplyByFive, substractThree, addTwo)(4);
console.log(composeRes) // 19
```

```js
const addTwo = (a) => a + 2;
const substractThree = (a) => a - 3;
const multiplyByFive = (a) => a * 5;
const divideBy = (a, b) => a / b;

const compose = (...fns) => val => fns.reduce((prev, fn) => fn(prev), val)
pipeRes = compose(multiplyByFive, substractThree, addTwo, x => divideBy(x, 2))(4);
console.log(pipeRes) // 9.5
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is eval</h2>

The eval() function evaluates JavaScript code represented as a string. The string can be a JavaScript expression, variable, statement, or sequence of statements.

```javascript
console.log(eval("1 + 2")); //  3
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is it recommended to use eval</h2>

No, it allows arbitrary code to be run which causes a security problem. As we know that the eval() function is used to run text as code. In most of the cases, it should not be necessary to use it.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of EvalError object</h2>

The EvalError object indicates an error regarding the global `eval()` function. Even though this exception is not thrown by JavaScript anymore, the EvalError object remains for compatibility. The syntax of this expression would be as below,

```javascript
new EvalError([message[, fileName[, lineNumber]]])
```

You can throw EvalError with in try...catch block as below,

```javascript
try {
    throw new EvalError('Eval function error', 'someFile.js', 100);
} catch (e) {
    console.log(e.message, e.name, e.fileName);   
}           // "Eval function error", "EvalError", "someFile.js"
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of uneval</h2>

The uneval() is an inbuilt function which is used to create a string representation of the source code of an Object. It is a top-level function and is not associated with any object. Let's see the below example to know more about it's functionality,

```javascript
var a = 1;
uneval(a); // returns a String containing 1
uneval(function user() {}); // returns "(function user(){})"
```

The `uneval()` function has been deprecated. It is recommended to use `toString()` for functions and `JSON.toStringify()` for other cases.

```javascript
function user() {}
console.log(user.toString()); // returns "(function user(){})"
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between uneval and eval</h2>

The `uneval` function returns the source of a given object; whereas the `eval` function does the opposite, by evaluating that source code in a different memory area. Let's see an example to clarify the difference,

```javascript
var msg = uneval(function greeting() {
    return "Hello, Good morning";
});
var greeting = eval(msg);
greeting(); // returns "Hello, Good morning"
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Can we define properties for functions</h2>

Yes, We can define properties for functions because functions are also objects.

```javascript
fn = function (x) {
    //Function code goes here
};

fn.name = "John";

fn.profile = function (y) {
    //Profile code goes here
};
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the way to find the number of parameters expected by a function</h2>

You can use `function.length` syntax to find the number of parameters expected by a function. Let's take an example of `sum` function to calculate the sum of numbers,

```javascript
function sum(num1, num2, num3, num4) {
    return num1 + num2 + num3 + num4;
}
sum.length; // 4 is the number of parameters expected.
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the function parameter rules</h2>

JavaScript functions follow below rules for parameters,

1. The function definitions do not specify data types for parameters. </br>
2. Do not perform type checking on the passed arguments.</br>
3. Do not check the number of arguments received. </br>
i.e, The below function follows the above rules,

```javascript
function functionName(parameter1, parameter2, parameter3) {
    console.log(parameter1); // 1
}
functionName(1);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between a parameter and an argument</h2>

Parameter is the variable name of a function definition whereas an argument represents the value given to a function when it is invoked. Let's explain this with a simple function

```js
function a(param1, param2) { // parameters
    console.log(param1 + param2)
}
a(1, 2) // arguments
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are default parameters</h2>

In ES5, we need to depend on logical OR operators to handle default values of function parameters. Whereas in ES6, Default function parameters feature allows parameters to be initialized with default values if no value or undefined is passed. Let's compare the behavior with an examples,

```javascript
//ES5
var calculateArea = function (height, width) {
    height = height || 50;
    width = width || 60;

    return width * height;
};
console.log(calculateArea()); //300
```

The default parameters makes the initialization more simpler,

```javascript
//ES6
var calculateArea = function (height = 50, width = 60) {
    return width * height;
};

console.log(calculateArea()); //300
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the output of below function calls</h2>

**Code snippet:**

```javascript
const circle = {
    radius: 20,
    diameter() {
        return this.radius * 2;
    },
    perimeter: () => 2 * Math.PI * this.radius,
};
```

```javascript
console.log(circle.diameter());
console.log(circle.perimeter());
```

**Output:**

The output is 40 and NaN. Remember that diameter is a regular function, whereas the value of perimeter is an arrow function. The `this` keyword of a regular function(i.e, diameter) refers to the surrounding scope which is a class(i.e, Shape object). Whereas this keyword of perimeter function refers to the surrounding scope which is a window object. Since there is no radius property on window objects it returns an undefined value and the multiple of number value returns NaN value.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between Function constructor and function declaration</h2>

The functions which are created with `Function constructor` do not create closures to their creation contexts but they are always created in the global scope. i.e, the function can access its own local variables and global scope variables only. Whereas function declarations can access outer function variables(closures) too.

Let's see this difference with an example,

**Function Constructor:**

```javascript
var a = 100;
function createFunction() {
    var a = 200;
    return new Function("return a;");
}
console.log(createFunction()()); // 100
```

**Function declaration:**

```javascript
var a = 100;
function createFunction() {
    var a = 200;
    return function func() {
        return a;
    };
}
console.log(createFunction()()); // 200
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a Proper Tail Call</h2>

First, we should know about tail call before talking about "Proper Tail Call". A tail call is a subroutine or function call performed as the final action of a calling function. Whereas **Proper tail call(PTC)** is a technique where the program or code will not create additional stack frames for a recursion when the function call is a tail call.

For example, the below classic or head recursion of factorial function relies on stack for each step. Each step need to be processed upto `n * factorial(n - 1)`

```javascript
function factorial(n) {
    if (n === 0) {
        return 1;
    }
return n * factorial(n - 1);
}
console.log(factorial(5)); //120
```

But if you use Tail recursion functions, they keep passing all the necessary data it needs down the recursion without relying on the stack.

```javascript
function factorial(n, acc = 1) {
    if (n === 0) {
        return acc;
    }
    return factorial(n - 1, n * acc);
}
console.log(factorial(5)); //120
```

The above pattern returns the same output as the first one. But the accumulator keeps track of total as an argument without using stack memory on recursive calls.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to detect if a function is called as constructor</h2>

You can use `new.target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call.

1. If a constructor or function invoked using the new operator, new.target returns a reference to the constructor or function. </br>
2. For function calls, new.target is undefined.

```javascript
function Myfunc() {
 if (new.target) {
   console.log("called with new");
 } else {
   console.log("not called with new");
 }
}

new Myfunc(); // called with new
Myfunc(); // not called with new
Myfunc.call({}); // not called with new
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the different kinds of generators</h2>

There are five kinds of generators,

**1. Generator function declaration:**

  ```javascript
  function* myGenFunc() {
    yield 1;
    yield 2;
    yield 3;
  }
  const genObj = myGenFunc();
  ```

**2. Generator function expressions:**

  ```javascript
  const myGenFunc = function* () {
    yield 1;
    yield 2;
    yield 3;
  };
  const genObj = myGenFunc();
  ```

**3. Generator method definitions in object literals:**

  ```javascript
  const myObj = {
    *myGeneratorMethod() {
      yield 1;
      yield 2;
      yield 3;
    },
  };
  const genObj = myObj.myGeneratorMethod();
  ```

**4. Generator method definitions in class:**

  ```javascript
  class MyClass {
    *myGeneratorMethod() {
      yield 1;
      yield 2;
      yield 3;
    }
  }
  const myObject = new MyClass();
  const genObj = myObject.myGeneratorMethod();
  ```

**5. Generator as a computed property:**

  ```javascript
  const SomeObj = {
    *[Symbol.iterator]() {
      yield 1;
      yield 2;
      yield 3;
    },
  };

  console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]
  ```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you define instance and non-instance properties</h2>

The Instance properties must be defined inside of class methods. For example, name and age properties defined inside constructor as below,

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
```

But Static(class) and prototype data properties must be defined outside of the ClassBody declaration. Let's assign the age value for Person class as below,

```javascript
Person.staticAge = 30;
Person.prototype.prototypeAge = 40;
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is pass by value and pass by reference</h2>

Pass-by-value creates a new space in memory and makes a copy of a value. Primitives such as string, number, boolean etc will actually create a new copy. Hence, updating one value doesn't impact the other value. i.e, The values are independent of each other.

```javascript
let a = 5;
let b = a;

b++;
console.log(a, b); //5, 6
```

In the above code snippet, the value of `a` is assigned to `b` and the variable `b` has been incremented. Since there is a new space created for variable `b`, any update on this variable doesn't impact the variable `a`.

Pass by reference doesn't create a new space in memory but the new variable adopts a memory address of an initial variable. Non-primitives such as objects, arrays and functions gets the reference of the initiable variable. i.e, updating one value will impact the other variable - **Mutable**.

```javascript
let user1 = {
    name: "John",
    age: 27,
};
let user2 = user1;
user2.age = 30;

console.log(user1.age, user2.age); // 30, 30
```

In the above code snippet, updating the `age` property of one object will impact the other property due to the same reference.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are hidden classes</h2>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is referential transparency</h2>

An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency. Pure functions are referentially transparent.

```javascript
const add = (x, y) => x + y;
const multiplyBy2 = (x) => x * 2;

//Now add (2, 3) can be replaced by 5.

multiplyBy2(add(2, 3));
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is module pattern</h2>

Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object. JavaScript doesn't have access specifiers similar to other languages(Java, Python, etc) to provide private scope. It uses IIFE (Immediately invoked function expression) to allow for private scopes. i.e., a closure that protect variables and methods.

The module pattern looks like below,

```javascript
(function () {
// Private variables or functions goes here.

return {
    // Return public variables or functions here.
};
})();
```

Let's see an example of a module pattern for an employee with private and public access,

```javascript
const createEmployee = (function () {
// Private
const name = "John";
const department = "Sales";
const getEmployeeName = () => name;
const getDepartmentName = () => department;

// Public
return {
    name,
    department,
    getName: () => getEmployeeName(),
    getDepartment: () => getDepartmentName(),
};
})();

console.log(createEmployee.name);
console.log(createEmployee.department);
console.log(createEmployee.getName());
console.log(createEmployee.getDepartment());
```

**Note:** It mimic the concepts of classes with private variables and methods.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is Function Composition</h2>

 It is an approach where the result of one function is passed on to the next function, which is passed to another until the final function is executed for the final result.

```javascript
//example
const double = (x) => x * 2;
const square = (x) => x * x;

var output1 = double(2);
var output2 = square(output1);
console.log(output2);

var output_final = square(double(2));
console.log(output_final);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of the this keyword in JavaScript</h2>

The `this` keyword in JavaScript is a special variable that is used within a function to refer to the object on which the function is invoked. The value of this depends on how the function is called. It allows functions to access and interact with the object they are bound to.

The this keyword in JavaScript is a reference to the object that owns or invokes the current function. Its value is determined by the calling context.

**Example 1: this in a Global Context**

```javascript
console.log(this);
```

In a global context, this refers to the global object (e.g., window in a browser).

**Example 2: this in a Function**

```javascript
function displayThis() {
  console.log(this);
}

displayThis();
```

In a regular function, this refers to the global object.

**Example 3: this in a Method**

```javascript
const person = {
  name: 'John',
  greet: function() {
    console.log('Hello, ' + this.name);
  }
};

person.greet();
```

In a method, this refers to the object that owns the method (person in the case).

**Example 4: this in an Event Handler**

```javascript
document.getElementById('myButton').addEventListener('click', function() {
  console.log(this);
});
```

In an event handler, this refers to the element that triggered the event (the button in this case).

**[⬆ Back to Top](#table-of-contents)**

### <h2>What Is Obfuscation in javascript</h2>

Obfuscation is the deliberate act of creating obfuscated javascript code(i.e, source or machine code) that is difficult for humans to understand. It is something similar to encryption, but a machine can understand the code and execute it.
Let's see the below function before Obfuscation,

```javascript
function greeting() {
console.log("Hello, welcome to JS world");
}
```

And after the code Obfuscation, it would be appeared as below,

```javascript
eval(
(function (p, a, c, k, e, d) {
    e = function (c) {
    return c;
    };
    if (!"".replace(/^/, String)) {
    while (c--) {
        d[c] = k[c] || c;
    }
    k = [
        function (e) {
        return d[e];
        },
    ];
    e = function () {
        return "\\w+";
    };
    c = 1;
    }
    while (c--) {
    if (k[c]) {
        p = p.replace(new RegExp("\\b" + e(c) + "\\b", "g"), k[c]);
    }
    }
    return p;
})(
    "2 1(){0.3('4, 7 6 5 8')}",
    9,
    9,
    "console|greeting|function|log|Hello|JS|to|welcome|world".split("|"),
    0,
    {}
)
);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do you need Obfuscation</h2>

Below are the few reasons for Obfuscation,

1. The Code size will be reduced. So data transfers between server and client will be fast. </br>
2. It hides the business logic from outside world and protects the code from others </br>
3. Reverse engineering is highly difficult </br>
4. The download time will be reduced </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is Minification</h2>

Minification is the process of removing all unnecessary characters(empty spaces are removed) and variables will be renamed without changing it's functionality. It is also a type of obfuscation .

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the advantages of minification</h2>

Normally it is recommended to use minification for heavy traffic and intensive requirements of resources. It reduces file sizes with below benefits,

1. Decreases loading times of a web page </br>
2. Saves bandwidth usages </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between Obfuscation and Encryption</h2>

Below are the main differences between Obfuscation and Encryption,

| Feature            | Obfuscation                                     | Encryption                                                              |
| ------------------ | ----------------------------------------------- | ----------------------------------------------------------------------- |
| Definition         | Changing the form of any data in any other form | Changing the form of information to an unreadable format by using a key |
| A key to decode    | It can be decoded without any key               | It is required                                                          |
| Target data format | It will be converted to a complex form          | Converted into an unreadable format                                     |

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the common tools used for minification</h2>

There are many online/offline tools to minify the javascript files,

1. Google's Closure Compiler </br>
2. UglifyJS2 </br>
3. jsmin </br>
4. javascript-minifier.com/ </br>
5. prettydiff.com </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you perform form validation using javascript</h2>

JavaScript can be used to perform HTML form validation. For example, if the form field is empty, the function needs to notify, and return false, to prevent the form being submitted.
Lets' perform user login in an html form,

```html
<form name="myForm" onsubmit="return validateForm()" method="post">
User name: <input type="text" name="uname" />
<input type="submit" value="Submit" />
</form>
```

And the validation on user login is below,

```javascript
function validateForm() {
var x = document.forms["myForm"]["uname"].value;
if (x == "") {
    alert("The username shouldn't be empty");
    return false;
}
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you perform form validation without javascript</h2>

You can perform HTML form validation automatically without using javascript. The validation enabled by applying the `required` attribute to prevent form submission when the input is empty.

```html
<form method="post">
<input type="text" name="uname" required />
<input type="submit" value="Submit" />
</form>
```

**Note:** Automatic form validation does not work in Internet Explorer 9 or earlier.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the DOM methods available for constraint validation</h2>

The below DOM methods are available for constraint validation on an invalid input,

1. checkValidity(): It returns true if an input element contains valid data. </br>
2. setCustomValidity(): It is used to set the validationMessage property of an input element. </br>
  Let's take an user login form with DOM validations

```javascript
function myFunction() {
 var userName = document.getElementById("uname");
 if (!userName.checkValidity()) {
   document.getElementById("message").innerHTML =
     userName.validationMessage;
 } else {
   document.getElementById("message").innerHTML =
     "Entered a valid username";
 }
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the available constraint validation DOM properties</h2>

Below are the list of some of the constraint validation DOM properties available,

1. validity: It provides a list of boolean properties related to the validity of an input element. </br>
2. validationMessage: It displays the message when the validity is false. </br>
3. willValidate: It indicates if an input element will be validated or not.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the list of validity properties</h2>

The validity property of an input element provides a set of properties related to the validity of data.

1. customError: It returns true, if a custom validity message is set. </br>
2. patternMismatch: It returns true, if an element's value does not match its pattern attribute. </br>
3. rangeOverflow: It returns true, if an element's value is greater than its max attribute. </br>
4. rangeUnderflow: It returns true, if an element's value is less than its min attribute. </br>
5. stepMismatch: It returns true, if an element's value is invalid according to step attribute. </br>
6. tooLong: It returns true, if an element's value exceeds its maxLength attribute. </br>
7. typeMismatch: It returns true, if an element's value is invalid according to type attribute. </br>
8. valueMissing: It returns true, if an element with a required attribute has no value.
9. valid: It returns true, if an element's value is valid.

**[⬆ Back to Top](#table-of-contents)**

### <h2>Give an example usage of rangeOverflow property</h2>

If an element's value is greater than its max attribute then rangeOverflow property returns true. For example, the below form submission throws an error if the value is more than 100,

```html
<input id="age" type="number" max="100" />
<button onclick="myOverflowFunction()">OK</button>
```

```javascript
function myOverflowFunction() {
    if (document.getElementById("age").validity.rangeOverflow) {
        alert("The mentioned age is not allowed");
    }
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an enum</h2>

An enum is a type restricting variables to one value from a predefined set of constants. JavaScript has no enums but typescript provides built-in enum support.

```javascript
enum Color {
    RED, GREEN, BLUE
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is enums feature available in javascript</h2>

No, javascript does not natively support enums. But there are different kinds of solutions to simulate them even though they may not provide exact equivalents. For example, you can use freeze or seal on object,

```javascript
var DaysEnum = Object.freeze({"monday":1, "tuesday":2, "wednesday":3, ...})
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you extend classes</h2>

The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class. It can be used to subclass custom classes as well as built-in objects. The syntax would be as below,

```javascript
class ChildClass extends ParentClass { ... }
```

Let's take an example of Square subclass from Polygon parent class,

```javascript
class Square extends Rectangle {
    constructor(length) {
        super(length, length);
        this.name = "Square";
    }

    get area() {
        return this.width * this.height;
    }

    set area(value) {
        this.area = value;
    }
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of setTimeout</h2>

The setTimeout() method is used to call a function or evaluate an expression after a specified number of milliseconds. For example, let's log a message after 2 seconds using setTimeout method,

```javascript
setTimeout(function () {
    console.log("Good morning");
}, 2000);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of clearTimeout method</h2>

The clearTimeout() function is used in javascript to clear the timeout which has been set by setTimeout() function before that. i.e, The return value of setTimeout() function is stored in a variable and it’s passed into the clearTimeout() function to clear the timer.

For example, the below setTimeout method is used to display the message after 3 seconds. This timeout can be cleared by the clearTimeout() method.

```javascript
<script>
var msg;
function greeting() {
    alert('Good morning');
}
function start() {
msg =setTimeout(greeting, 3000);

}

function stop() {
    clearTimeout(msg);
}
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the use of setInterval</h2>

The setInterval() method is used to call a function or evaluate an expression at specified intervals (in milliseconds). For example, let's log a message after 2 seconds using setInterval method,

```javascript
setInterval(function () {
    console.log("Good morning");
}, 2000);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of clearInterval method</h2>

The clearInterval() function is used in javascript to clear the interval which has been set by setInterval() function. i.e, The return value returned by setInterval() function is stored in a variable and it’s passed into the clearInterval() function to clear the interval.

For example, the below setInterval method is used to display the message for every 3 seconds. This interval can be cleared by the clearInterval() method.

```javascript
<script>
var msg;
function greeting() {
    alert('Good morning');
}

function start() {
    msg = setInterval(greeting, 3000);
}

function stop() {
    clearInterval(msg);
}
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the difference between setTimeout, setImmediate and process.nextTick</h2>

1. **Set Timeout:** setTimeout() is to schedule execution of a one-time callback after delay milliseconds. </br>
2. **Set Immediate:** The setImmediate function is used to execute a function right after the current event loop finishes. </br>
3. **Process NextTick:** If process.nextTick() is called in a given phase, all the callbacks passed to process.nextTick() will be resolved before the event loop continues. This will block the event loop and create I/O Starvation if process.nextTick() is called recursively.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to cancel a fetch request</h2>

Until a few days back, One shortcoming of native promises is no direct way to cancel a fetch request. But the new `AbortController` from js specification allows you to use a signal to abort one or multiple fetch calls.
The basic flow of cancelling a fetch request would be as below,

1. Create an `AbortController` instance
2. Get the signal property of an instance and pass the signal as a fetch option for signal
3. Call the AbortController's abort property to cancel all fetches that use that signal
For example, let's pass the same signal to multiple fetch calls will cancel all requests with that signal,

```javascript
const controller = new AbortController();
const { signal } = controller;

fetch("http://localhost:8000", { signal })
.then((response) => {
    console.log(`Request 1 is complete!`);
})
.catch((e) => {
    if (e.name === "AbortError") {
    // We know it's been canceled!
    }
});

fetch("http://localhost:8000", { signal })
.then((response) => {
    console.log(`Request 2 is complete!`);
})
.catch((e) => {
    if (e.name === "AbortError") {
    // We know it's been canceled!
    }
});

// Wait 2 seconds to abort both requests
setTimeout(() => controller.abort(), 2000);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you display data in a tabular format using console object</h2>

The `console.table()` is used to display data in the console in a tabular format to visualize complex arrays or objects.

```js
const users = [
    { name: "John", id: 1, city: "Delhi" },
    { name: "Max", id: 2, city: "London" },
    { name: "Rod", id: 3, city: "Paris" },
];
console.table(users);
```

**Not:** Remember that `console.table()` is not supported in IE.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the tools or techniques used for debugging JavaScript code</h2>

You can use below tools or techniques for debugging javascript

1. Chrome Devtools </br>
2. debugger statement </br>
3. Good old console.log statement </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a debugger statement</h2>

The debugger statement invokes any available debugging functionality, such as setting a breakpoint. If no debugging functionality is available, this statement has no effect.
For example, in the below function a debugger statement has been inserted. So
execution is paused at the debugger statement just like a breakpoint in the script source.

```javascript
function getProfile() {
    // code goes here
    debugger;
    // code goes here
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of breakpoints in debugging</h2>

You can set breakpoints in the javascript code once the debugger statement is executed and the debugger window pops up. At each breakpoint, javascript will stop executing, and let you examine the JavaScript values. After examining values, you can resume the execution of code using the play button.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the placeholders from console object</h2>

Below are the list of placeholders available from console object,

1. %o — It takes an object, </br>
2. %s — It takes a string, </br>
3. %d — It is used for a decimal or integer
  These placeholders can be represented in the console.log as below

```javascript
const user = { name: "John", id: 1, city: "Delhi" };
console.log(
 "Hello %s, your details %o are available in the object form",
 "John",
 user
); // Hello John, your details {name: "John", id: 1, city: "Delhi"} are available in object
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is it possible to add CSS to console messages</h2>

Yes, you can apply CSS styles to console messages similar to html text on the web page.

```javascript
console.log(
"%c The text has blue color, with large font and red background",
"color: blue; font-size: x-large; background: red"
);
```

**Note:** All CSS styles can be applied to console messages.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of dir method of console object</h2>

The `console.dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON.

```javascript
const user = { name: "John", id: 1, city: "Delhi" };
console.dir(user);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is it possible to debug HTML elements in console</h2>

Yes, it is possible to get and debug HTML elements in the console just like inspecting elements.

```javascript
const element = document.getElementsByTagName("body")[0];
console.log(element);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you group and nest console output<h2>

The `console.group()` can be used to group related log messages to be able to easily read the logs and use console.groupEnd()to close the group. Along with this, you can also nest groups which allows to output message in hierarchical manner.

For example, if you’re logging a user’s details:

```js
console.group("User Details");
console.log("name: Sudheer Jonna");
console.log("job: Software Developer");

// Nested Group
console.group("Address");
console.log("Street: Commonwealth");
console.log("City: Los Angeles");
console.log("State: California");

// Close nested group
console.groupEnd();

// Close outer group
console.groupEnd();
```

You can also use `console.groupCollapsed()` instead of `console.group()` if you want the groups to be collapsed by default.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do style the console output using CSS</h2>

You can add CSS styling to the console output using the CSS format content specifier %c. The console string message can be appended after the specifier and CSS style in another argument. Let's print the red the color text using console.log and CSS specifier as below,

```js
console.log("%cThis is a red text", "color:red");
```

It is also possible to add more styles for the content. For example, the font-size can be modified for the above text

```js
console.log(
    "%cThis is a red text with bigger font",
    "color:red; font-size:20px"
);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you encode an URL</h2>

The encodeURI() function is used to encode complete URI which has special characters except (, / ? : @ & = + $ #) characters.

```javascript
var uri = "https://mozilla.org/?x=шеллы";
var encoded = encodeURI(uri);
console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you decode an URL</h2>

The decodeURI() function is used to decode a Uniform Resource Identifier (URI) previously created by encodeURI().

```javascript
var uri = "https://mozilla.org/?x=шеллы";
var encoded = encodeURI(uri);
console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
try {
    console.log(decodeURI(encoded)); // "https://mozilla.org/?x=шеллы"
} catch (e) {
    // catches a malformed URI
    console.error(e);
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the various url properties of location object</h2>

The below `Location` object properties can be used to access URL components of the page,

1. href - The entire URL </h2>
2. protocol - The protocol of the URL </h2>
3. host - The hostname and port of the URL </h2>
4. hostname - The hostname of the URL </h2>
5. port - The port number in the URL </h2>
6. pathname - The path name of the URL </h2>
7. search - The query portion of the URL </h2>
8. hash - The anchor portion of the URL </h2>

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you get the current url with javascript<h2>

You can use `window.location.href` expression to get the current url path and you can use the same expression for updating the URL too. You can also use `document.URL` for read-only purposes but this solution has issues in FF.

```javascript
console.log("location.href", window.location.href); // Returns full URL
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do I modify the url without reloading the page</h2>

The `window.location.href` property will be helpful to modify the url but it reloads the page. HTML5 introduced the `history.pushState()` and `history.replaceState()` methods, which allow you to add and modify history entries, respectively. For example, you can use pushState as below,

```javascript
window.history.pushState("page2", "Title", "/page2.html");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you decode or encode a URL in JavaScript</h2>

`encodeURI()` function is used to encode an URL. This function requires a URL string as a parameter and return that encoded string. </br>
`decodeURI()` function is used to decode an URL. This function requires an encoded URL string as parameter and return that decoded string.

**Note:** If you want to encode characters such as `/ ? : @ & = + $ #` then you need to use `encodeURIComponent()`.

```javascript
let uri = "https://mozilla.org/?x=шеллы";
let encoded_uri = encodeURI(uri); // output - https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
let decoded_uri = decodeURI(encoded_uri); // output - https://mozilla.org/?x=шеллы
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do get query string values in javascript</h2>

You can use URLSearchParams to get query string values in javascript. Let's see an example to get the client code value from URL query string,

```javascript
const urlParams = new URLSearchParams(window.location.search);
const clientCode = urlParams.get("clientCode");
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you print the contents of web page</h2>

The window object provided a print() method which is used to print the contents of the current window. It opens a Print dialog box which lets you choose between various printing options. Let's see the usage of print method in an example,

```html
<input type="button" value="Print" onclick="window.print()" />
```

**Note:** In most browsers, it will block while the print dialog is open.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you access history in javascript</h2>

The window.history object contains the browser's history. You can load previous and next URLs in the history using back() and next() methods.

```javascript
function goBack() {
    window.history.back();
}

function goForward() {
    window.history.forward();
}
```

**Note:** You can also access history without window prefix.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you detect caps lock key turned on or not</h2>

The `mouseEvent getModifierState()` is used to return a boolean value that indicates whether the specified modifier key is activated or not. The modifiers such as CapsLock, ScrollLock and NumLock are activated when they are clicked, and deactivated when they are clicked again.

Let's take an input element to detect the CapsLock on/off behavior with an example,

```html
<input type="password" onmousedown="enterInput(event)" />

<p id="feedback"></p>

<script>
    function enterInput(e) {
    var flag = e.getModifierState("CapsLock");
    if (flag) {
        document.getElementById("feedback").innerHTML = "CapsLock activated";
    } else {
        document.getElementById("feedback").innerHTML =
        "CapsLock not activated";
    }
    }
</script>
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a service worker</h2>

A Service worker is basically a script (JavaScript file) that runs in the background, separate from a web page and provides features that don't need a web page or user interaction. Some of the major features of service workers are Rich offline experiences(offline first web application development), periodic background syncs, push notifications, intercept and handle network requests and programmatically managing a cache of responses.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you manipulate DOM using a service worker</h2>

Service worker can't access the DOM directly. But it can communicate with the pages it controls by responding to messages sent via the `postMessage` interface, and those pages can manipulate the DOM.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you reuse information across service worker restarts</h2>

The problem with service worker is that it gets terminated when not in use, and restarted when it's next needed, so you cannot rely on global state within a service worker's `onfetch` and `onmessage` handlers. In this case, service workers will have access to IndexedDB API in order to persist and reuse across restarts.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you check web workers browser support</h2>

You need to check browser support for web workers before using it

```javascript
if (typeof Worker !== "undefined") {
    // code for Web worker support.
} else {
    // Sorry! No Web Worker support..
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Give an example of a web worker</h2>

You need to follow below steps to start using web workers for counting example

1. Create a Web Worker File: You need to write a script to increment the count value. Let's name it as counter.js

```javascript
let i = 0;

function timedCount() {
    i = i + 1;
    postMessage(i);
    setTimeout("timedCount()", 500);
}

timedCount();
```

Here postMessage() method is used to post a message back to the HTML page

1. Create a Web Worker Object: You can create a web worker object by checking for browser support. Let's name this file as web_worker_example.js

```javascript
if (typeof w == "undefined") {
    w = new Worker("counter.js");
}
```

and we can receive messages from web worker

```javascript
w.onmessage = function (event) {
    document.getElementById("message").innerHTML = event.data;
};
```

1. Terminate a Web Worker:
    Web workers will continue to listen for messages (even after the external script is finished) until it is terminated. You can use the terminate() method to terminate listening to the messages.

```javascript
w.terminate();
```

1. Reuse the Web Worker: If you set the worker variable to undefined you can reuse the code

```javascript
w = undefined;
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the restrictions of web workers on DOM</h2>

WebWorkers don't have access to below javascript objects since they are defined in an external files

1. Window object </br>
2. Document object </br>
3. Parent object

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a strict mode in javascript</h2>


Strict Mode is a new feature in ECMAScript 5 that allows you to place a program, or a function, in a “strict” operating context. This way it prevents certain actions from being taken and throws more exceptions. The literal expression `"use strict";` instructs the browser to use the javascript code in the Strict mode.

Strict Mode in Javascript is something that I always hear about in various forums but never actually implemented it. Well, I thought this is a good opportunity to do some research on.

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do you need strict mode</h2>

Strict mode is useful to write "secure" JavaScript by notifying "bad syntax" into real errors. For example, it eliminates accidentally creating a global variable by throwing an error and also throws an error for assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you declare strict mode</h2>

The strict mode is declared by adding "use strict"; to the beginning of a script or a function.
If declared at the beginning of a script, it has global scope.

```javascript
"use strict";
x = 3.14; // This will cause an error because x is not declared
```

and if you declare inside a function, it has local scope

```javascript
x = 3.14; // This will not cause an error.
myFunction();

function myFunction() {
    "use strict";
    y = 3.14; // This will cause an error
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the list of cases error thrown from non-strict mode to strict mode</h2>

When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script

1. When you use Octal syntax

```javascript
var n = 022;
```

2. Using `with` statement </br>
3. When you use delete operator on a variable name </br>
4. Using eval or arguments as variable or function argument name </br>
5. When you use newly reserved keywords </br>
6. When you declare a function in a block </br>

```javascript
if (someCondition) {
function f() {}
}
```

Hence, the errors from above cases are helpful to avoid errors in development/production environments.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How to verify if a variable is an array<h2>

It is possible to check if a variable is an array instance using 3 different ways,

**1. Array.isArray() method:**

The `Array.isArray(value)` utility function is used to determine whether value is an array or not. This function returns a true boolean value if the variable is an array and a false value if it is not.

```javascript
const numbers = [1, 2, 3];
const user = { name: "John" };
Array.isArray(numbers); // true
Array.isArray(user); //false
```

**2. instanceof operator:**

The instanceof operator is used to check the type of an array at run time. It returns true if the type of a variable is an Array other false for other type.

```javascript
const numbers = [1, 2, 3];
const user = { name: "John" };
console.log(numbers instanceof Array); // true
console.log(user instanceof Array); // false
```

**3. Checking constructor type:**

The constructor property of the variable is used to determine whether the variable Array type or not.

```javascript
const numbers = [1, 2, 3];
const user = { name: "John" };
console.log(numbers.constructor === Array); // true
console.log(user.constructor === Array); // false
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is const variable makes the value immutable</h2>

No, the const variable doesn't make the value immutable. But it disallows subsequent assignments(i.e, You can declare with assignment but can't assign another value later)

```javascript
const userList = [];
userList.push("John"); // Can mutate even though it can't re-assign
console.log(userList); // ['John']
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the precedence order between local and global variables</h2>

A local variable takes precedence over a global variable with the same name. Let's see this behavior in an example.

```javascript
var msg = "Good morning";
function greeting() {
msg = "Good Evening";
console.log(msg); // Good Evening
}
greeting();
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you assign default values to variables</h2>

You can use the logical or operator `||` in an assignment expression to provide a default value. The syntax looks like as below,

```javascript
var a = b || c;
```

As per the above expression, variable 'a 'will get the value of 'c' only if 'b' is falsy (if is null, false, undefined, 0, empty string, or NaN), otherwise 'a' will get the value of 'b'.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the benefits of keeping declarations at the top</h2>

It is recommended to keep all declarations at the top of each script or function. The benefits of doing this are,

1. Gives cleaner code
2. It provides a single place to look for local variables
3. Easy to avoid unwanted global variables
4. It reduces the possibility of unwanted re-declarations

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of the let keyword</h2>

The `let` statement declares a **block scope local variable**. Hence the variables defined with let keyword are limited in scope to the block, statement, or expression on which it is used. Whereas variables declared with the `var` keyword used to define a variable globally, or locally to an entire function regardless of block scope.

Let's take an example to demonstrate the usage,

```javascript
let counter = 30;
if (counter === 30) {
    let counter = 31;
    console.log(counter); // 31
}
console.log(counter); // 30 (because the variable in if block won't exist here)
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the reason to choose the name let as a keyword</h2>

`let` is a mathematical statement that was adopted by early programming languages like **Scheme** and **Basic**. It has been borrowed from dozens of other languages that use `let` already as a traditional keyword as close to `var` as possible.

**[⬆ Back to Top](#table-of-contents)**

### <h2>Can I redeclare let and const variables</h2>

No, you cannot redeclare let and const variables. If you do, it throws below error

```bash
Uncaught SyntaxError: Identifier 'someVariable' has already been declared
```

**Explanation:** The variable declaration with `var` keyword refers to a function scope and the variable is treated as if it were declared at the top of the enclosing scope due to hoisting feature. So all the multiple declarations contributing to the same hoisted variable without any error. Let's take an example of re-declaring variables in the same scope for both var and let/const variables.

```javascript
var name = "John";
function myFunc() {
    var name = "Nick";
    var name = "Abraham"; // Re-assigned in the same function block
    alert(name); // Abraham
}
myFunc();
alert(name); // John
```

The block-scoped multi-declaration throws syntax error,

```javascript
let name = "John";
function myFunc() {
    let name = "Nick";
    let name = "Abraham"; // Uncaught SyntaxError: Identifier 'name' has already been declared
    alert(name);
}

myFunc();
alert(name);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are global variables</h2>

Global variables are those that are available throughout the length of the code without any scope. The var keyword is used to declare a local variable but if you omit it then it will become global variable

```javascript
msg = "Hello"; // var is missing, it becomes global variable
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the problems with global variables</h2>

The problem with global variables is the conflict of variable names of local and global scope. It is also difficult to debug and test the code that relies on global variables.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you redeclare variables in switch block without an error</h2>

If you try to redeclare variables in a `switch block` then it will cause errors because there is only one block. For example, the below code block throws a syntax error as below,

```javascript
let counter = 1;
switch (x) {
    case 0:
        let name;
        break;
    case 1:
        let name; // SyntaxError for redeclaration.
        break;
}
```

To avoid this error, you can create a nested block inside a case clause and create a new block scoped lexical environment.

```javascript
let counter = 1;
switch (x) {
    case 0: {
        let name;
        break;
    }
    case 1: {
        let name; // No SyntaxError for redeclaration.
        break;
    }
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the pros and cons of for loop</h2>

The for-loop is a commonly used iteration syntax in javascript. It has both pros and cons

#### Pros

1. Works on every environment
2. You can use break and continue flow control statements

#### Cons

1. Too verbose
2. Imperative
3. You might face one-by-off errors

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are break and continue statements</h2>

The break statement is used to "jump out" of a loop. i.e, It breaks the loop and continues executing the code after the loop.

```javascript
for (i = 0; i < 10; i++) {
    if (i === 5) {
        break;
    }
    text += "Number: " + i + "<br>";
}
```

The continue statement is used to "jump over" one iteration in the loop. i.e, It breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.

```javascript
for (i = 0; i < 10; i++) {
    if (i === 5) {
        continue;
    }
    text += "Number: " + i + "<br>";
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are js labels</h2>

The label statement allows us to name loops and blocks in JavaScript. We can then use these labels to refer back to the code later. For example, the below code with labels avoids printing the numbers when they are same,

```javascript
var i, j;

loop1: for (i = 0; i < 3; i++) {
loop2: for (j = 0; j < 3; j++) {
    if (i === j) {
    continue loop1;
    }
    console.log("i = " + i + ", j = " + j);
}
}

// Output is:
//   "i = 1, j = 0"
//   "i = 2, j = 0"
//   "i = 2, j = 1"
```

```javascript
let sum = 0, a = 1;
outerloop: while (true) { // Label for outer loop
	a = 1;
	innerloop: while (a < 3) { // Label for inner loop
		sum += a;
		if (sum > 12) {
			break outerloop; // Break outer loop from inner loop
		}
		console.log("sum = " + sum);
		a++;
	}
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the conventions to be followed for the usage of switch case</h2>

Below are the list of conventions should be taken care,

1. The expression can be of type either number or string. </br>
2. Duplicate values are not allowed for the expression. </br>
3. The default statement is optional. If the expression passed to switch does not match with any case value then the statement within default case will be executed. </br>
4. The break statement is used inside the switch to terminate a statement sequence. </br>
5. The break statement is optional. But if it is omitted, the execution will continue on into the next case. </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of switch-case</h2>

The switch case statement in JavaScript is used for decision making purposes. In a few cases, using the switch case statement is going to be more convenient than if-else statements. The syntax would be as below,

```javascript
switch (expression)
{
    case value1:
        statement1;
        break;
    case value2:
        statement2;
        break;
    .
    .
    case valueN:
        statementN;
        break;
    default:
        statementDefault;
}
```

The above multi-way branch statement provides an easy way to dispatch execution to different parts of code based on the value of the expression.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the two types of loops in javascript</h2>

1. **Entry Controlled loops:** In this kind of loop type, the test condition is tested before entering the loop body. For example, For Loop and While Loop comes under this category.

2. **Exit Controlled Loops:** In this kind of loop type, the test condition is tested or evaluated at the end of the loop body. i.e, the loop body will execute at least once irrespective of test condition true or false. For example, do-while loop comes under this category.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an empty statement and purpose of it</h2>

The empty statement is a semicolon (;) indicating that no statement will be executed, even if JavaScript syntax requires one. Since there is no action with an empty statement you might think that it's usage is quite less, but the empty statement is occasionally useful when you want to create a loop that has an empty body. For example, you can initialize an array with zero values as below,

```javascript
// Initialize an array a
for (let i = 0; i < a.length; a[i++] = 0);
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an event loop</h2>

The event loop is a process that continuously monitors both the call stack and the event queue and checks whether or not the call stack is empty. If the call stack is empty and there are pending events in the event queue, the event loop dequeues the event from the event queue and pushes it to the call stack. The call stack executes the event, and any additional events generated during the execution are added to the end of the event queue.

**Note:** The event loop allows Node.js to perform non-blocking I/O operations, even though JavaScript is single-threaded, by offloading operations to the system kernel whenever possible. Since most modern kernels are multi-threaded, they can handle multiple operations executing in the background.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you create an infinite loop</h2>

You can create infinite loops using for and while loops without using any expressions. The for loop construct or syntax is better approach in terms of ESLint and code optimizer tools,

```javascript
for (;;) {}
while (true) {}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Why do you need to avoid with statement</h2>

JavaScript's with statement was intended to provide a shorthand for writing recurring accesses to objects. So it can help reduce file size by reducing the need to repeat a lengthy object reference without performance penalty. Let's take an example where it is used to avoid redundancy when accessing an object several times.

```javascript
a.b.c.greeting = "welcome";
a.b.c.age = 32;
```

Using `with` it turns this into:

```javascript
with (a.b.c) {
greeting = "welcome";
age = 32;
}
```

But this `with` statement creates performance problems since one cannot predict whether an argument will refer to a real variable or to a property inside the with argument.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the output of below for loops</h2>

```javascript
for (var i = 0; i < 4; i++) {
    setTimeout(() => console.log(i)); // global scope
}

for (let i = 0; i < 4; i++) {
    setTimeout(() => console.log(i)); // block scope
}
```

The output of the above for loops is 4 4 4 4 and 0 1 2 3

**Explanation:** Due to the event queue/loop of javascript, the `setTimeout` callback function is called after the loop has been executed. Since the variable i is declared with the `var` keyword it became a global variable and the value was equal to 4 using iteration when the time `setTimeout` function is invoked. Hence, the output of the first loop is `4 4 4 4`.

Whereas in the second loop, the variable i is declared as the `let` keyword it becomes a block scoped variable and it holds a new value(0, 1 ,2 3) for each iteration. Hence, the output of the first loop is `0 1 2 3`.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is for...of statement</h2>

The for...of statement creates a loop iterating over iterable objects or elements such as built-in String, Array, Array-like objects (like arguments or NodeList), TypedArray, Map, Set, and user-defined iterables. The basic usage of for...of statement on arrays would be as below,

```javascript
let arrayIterable = [10, 20, 30, 40, 50];

for (let value of arrayIterable) {
    value++;
    console.log(value); // 11 21 31 41 51
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are tasks in event loop</h2>

A task is any javascript code/program which is scheduled to be run by the standard mechanisms such as initially starting to run a program, run an event callback, or an interval or timeout being fired. All these tasks are scheduled on a task queue.
Below are the list of use cases to add tasks to the task queue,

1. When a new javascript program is executed directly from console or running by the `<script>` element, the task will be added to the task queue. </br>
2. When an event fires, the event callback added to task queue </br>
3. When a setTimeout or setInterval is reached, the corresponding callback added to task queue </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are different event loops</h2>

In JavaScript, there are multiple event loops that can be used depending on the context of your application. The most common event loops are:

1. The Browser Event Loop </br>
2. The Node.js Event Loop </br>


- Browser Event Loop: The Browser Event Loop is used in client-side JavaScript applications and is responsible for handling events that occur within the browser environment, such as user interactions (clicks, keypresses, etc.), HTTP requests, and other asynchronous actions.

- The Node.js Event Loop is used in server-side JavaScript applications and is responsible for handling events that occur within the Node.js runtime environment, such as file I/O, network I/O, and other asynchronous actions.

**[⬆ Back to Top](#table-of-contents)**

### </h2>What are the differences between for...of and for...in statements</h2>

Both for...in and for...of statements iterate over js data structures. The only difference is over what they iterate:

1. for..in iterates over all enumerable property keys of an object </br>
2. for..of iterates over the values of an iterable object. <br>

Let's explain this difference with an example,

```javascript
let arr = ["a", "b", "c"];

arr.newProp = "newVlue";

// key are the property keys
for (let key in arr) {
 console.log(key); // 0, 1, 2 & newValue
}

// value are the property values
for (let value of arr) {
 console.log(value); // a, b, c
}
```

Since for..in loop iterates over the keys of the object, the first loop logs 0, 1, 2 and newProp while iterating over the array object. The for..of loop iterates over the values of a arr data structure and logs a, b, c in the console.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of double exclamation</h2>

The double exclamation or negation(!!) ensures the resulting type is a boolean. If it was falsey (e.g. 0, null, undefined, etc.), it will be false, otherwise, it will be true.
For example, you can test IE version using this expression as below,

```javascript
let isIE8 = false;
isIE8 = !!navigator.userAgent.match(/MSIE 8.0/);
console.log(isIE8); // returns true or false
```

If you don't use this expression then it returns the original value.

```javascript
console.log(navigator.userAgent.match(/MSIE 8.0/)); // returns either an Array or null
```

**Note:** The expression !! is not an operator, but it is just twice of ! operator.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a comma operator and their Advantagess</h2>

The comma operator is used to evaluate each of its operands from left to right and returns the value of the last operand. This is totally different from comma usage within arrays, objects, and function arguments and parameters. For example, the usage for numeric expressions would be as below,

```javascript
var x = 1;
x = (x++, x);

console.log(x); // 2
```

**Advantage**

It is normally used to include multiple expressions in a location that requires a single expression. One of the common usages of this comma operator is to supply multiple parameters in a `for` loop. For example, the below for loop uses multiple expressions in a single location using comma operator,

```javascript
for (var a = 0, b =10; a <= 10; a++, b--)
```

You can also use the comma operator in a return statement where it processes before returning.

```javascript
function myFunction() {
var a = 1;
return (a += 10), a; // 11
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Is the '!--' notation represents a special operator</h2>

No,that's not a special operator. But it is a combination of 2 standard operators one after the other,

1. A logical not (!) </br>
2. A prefix decrement (--)

At first, the value decremented by one and then tested to see if it is equal to zero or not for determining the truthy/falsy value.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of double tilde operator</h2>

The double tilde operator(~~) is known as double NOT bitwise operator. This operator is a slightly quicker substitute for Math.floor().

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is nullish coalescing operator (??)?</h2>

It is a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand. This can be contrasted with the logical OR (||) operator, which returns the right-hand side operand if the left operand is any falsy value, not only null or undefined.

```js
console.log(null ?? true); // true
console.log(false ?? true); // false
console.log(undefined ?? true); // true
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a conditional operator in javascript</h2>

The conditional (ternary) operator is the only JavaScript operator that takes three operands which acts as a shortcut for if statements.

```javascript
var isAuthenticated = false;
console.log(
isAuthenticated ? "Hello, welcome" : "Sorry, you are not authenticated"
); //Sorry, you are not authenticated
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>Can you apply chaining on conditional operator</h2>

Yes, you can apply chaining on conditional operators similar to if … else if … else if … else chain. The syntax is going to be as below,

```javascript
function traceValue(someParam) {
return condition1
    ? value1
    : condition2
    ? value2
    : condition3
    ? value3
    : value4;
}

// The above conditional operator is equivalent to:

function traceValue(someParam) {
if (condition1) {
    return value1;
} else if (condition2) {
    return value2;
} else if (condition3) {
    return value3;
} else {
    return value4;
}
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the purpose of the delete operator</h2>

The delete operator is used to delete the property as well as its value.

```javascript
var user = { firstName: "John", lastName:"Doe", age: 20 };
delete user.age;

console.log(user); // {firstName: "John", lastName:"Doe"}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is typeof operator</h2>

You can use the JavaScript typeof operator to find the type of a JavaScript variable. It returns the type of a variable or an expression.

```javascript
typeof "John Abraham"; // Returns "string"
typeof (1 + 2); // Returns "number"
typeof [1, 2, 3]; // Returns "object" because all arrays are also objects
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a void operator</h2>

The `void` operator used to evaluates the given expression and then returns undefined(i.e, without returning value). The syntax would be as below,

```javascript
void expression;
void(expression);
```

Let's display a message without any redirection or reload

```javascript
function foo() {
    return void 10;
}
console.log(foo()); // undefined
```

**Note:** This operator is often used to obtain the undefined primitive value, using "void(0)".

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is an Unary operator</h2>

| Operator           | Description                                                          |
| ------------------ | -------------------------------------------------------------------- |
| Unary plus (+)     | Tries to convert the operand into a number                           |
| Unary negation (-) | Tries to convert the operand into a number and negates after         |
| Increment (++)     | Adds one to its operand                                              |
| Decrement (--)     | Decrements by one from its operand                                   |
| Logical NOT (!)    | Converts to boolean value then negates it                            |
| typeof             | Returns a string which is the type of the operand                    |
| delete             | Deletes specific index of an array or specific property of an object |
| void               | Discards a return value of an expression.                            |

A unary operation is an operation with only one operand. This operand comes either before or after the operator.

The unary(+) operator is used to convert a variable to a number.If the variable cannot be converted, it will still become a number but with the value NaN. Let's see this behavior in an action.

```javascript
var x = "100";
var y = +x;
console.log(typeof x, typeof y); // string, number

var a = "Hello";
var b = +a;
console.log(typeof a, typeof b, b); // string, number, NaN
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the output of below console statement with unary operator</h2>

Let's take console statement with unary operator as given below,

```javascript
console.log(+"Hello");
```

The output of the above console log statement returns NaN. Because the element is prefixed by the unary operator and the JavaScript interpreter will try to convert that element into a number type. Since the conversion fails, the value of the statement results in NaN value.

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you create self string using special characters</h2>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the output of prepend additive operator on falsy values</h2>

If you prepend the additive(+) operator on falsy values(null, undefined, NaN, false, ""), the falsy value converts to a number value zero. Let's display them on browser console as below,

```javascript
console.log(+null); // 0
console.log(+undefined); // NaN
console.log(+false); // 0
console.log(+NaN); // NaN
console.log(+""); // 0
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a Spread operator</h2>

The spread operator and rest parameter have the same syntax which is three dots(…). Even though they have the same syntax they differ in functions

The spread operator helps us expand an iterable ( arrays / objects / strings ) and allows us to quickly copy all or part of an existing array or object into another array or object

```javascript
l=[1,2,3]
console.log([...l]) // [ 1, 2, 3 ]

const numbersOne = [1, 2, 3];
const numbersTwo = [4, 5, 6];
const numbersCombined = [...numbersOne, ...numbersTwo];
console.log(numbersCombined) // [ 1, 2, 3, 4, 5, 6 ]
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is a Rest operator</h2>

The rest(...) parameter is converse to the spread operator. while the spread operator expands elements of an iterable, the rest operator compresses them, and allows a function to accept an indefinite number of arguments as an array.

```javascript
sum = (...values) => {
    console.log(values)
    let total = 0
    for(const val of values) {
        total += val
    }
    return total
}
console.log(sum(1, 2, 3)); //Output: 6
console.log(sum(1, 2, 3, 4)); //Output: 10
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is the output of below spread operator array</h2>

```javascript
[..."John Resig"];
```

The output of the array is ['J', 'o', 'h', 'n', '', 'R', 'e', 's', 'i', 'g']
**Explanation:** The string is an iterable type and the spread operator within an array maps every character of an iterable to one element. Hence, each character of a string becomes an element within an Array.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between spread operator and rest parameter</h2>

Rest parameter collects all remaining elements into an array. Whereas Spread operator allows iterables( arrays / objects / strings ) to be expanded into single arguments/elements. i.e, Rest parameter is opposite to the spread operator.

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the differences between arguments object and rest parameter</h2>

There are three main differences between arguments object and rest parameters

1. The arguments object is an array-like but not an array. Whereas the rest parameters are array instances.
2. The arguments object does not support methods such as sort, map, forEach, or pop. Whereas these methods can be used in rest parameters.
3. The rest parameters are only the ones that haven’t been given a separate name, while the arguments object contains all arguments passed to the function

**[⬆ Back to Top](#table-of-contents)**

### <h2>What happens if you do not use rest parameter as a last argument</h2>

The rest parameter should be the last argument, as its job is to collect all the remaining arguments into an array. For example, if you define a function like below it doesn’t make any sense and will throw an error.

```javascript
function someFunc(a,…b,c){
//You code goes here
return;
}
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are the bitwise operators available in javascript</h2>

Below are the list of bitwise logical operators used in JavaScript

1. Bitwise AND ( & ) </br>
2. Bitwise OR ( | ) </br>
3. Bitwise XOR ( ^ ) </br>
4. Bitwise NOT ( ~ ) </br>
5. Left Shift ( << ) </br>
6. Sign Propagating Right Shift ( >> ) </br>
7. Zero fill Right Shift ( >>> ) </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are various operators supported by javascript</h2>

An operator is capable of manipulating(mathematical and logical computations) a certain value or operand. There are various operators supported by JavaScript as below,

1. **Arithmetic Operators:** Includes + (Addition),– (Subtraction), \* (Multiplication), / (Division), % (Modulus), + + (Increment) and – – (Decrement) </br>
2. **Comparison Operators:** Includes = =(Equal),!= (Not Equal), ===(Equal with type), > (Greater than),> = (Greater than or Equal to),< (Less than),<= (Less than or Equal to) </br>
3. **Logical Operators:** Includes &&(Logical AND),||(Logical OR),!(Logical NOT) </br>
4. **Assignment Operators:** Includes = (Assignment Operator), += (Add and Assignment Operator), – = (Subtract and Assignment Operator), \*= (Multiply and Assignment), /= (Divide and Assignment), %= (Modules and Assignment) </br>
5. **Ternary Operators:** It includes conditional(: ?) Operator </br>
6. **typeof Operator:** It uses to find type of variable. The syntax looks like `typeof variable` </br>

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is destructuring aliases</h2>

Sometimes you would like to have a destructured variable with a different name than the property name. In that case, you'll use a `: newName` to specify a name for the variable. This process is called destructuring aliases.

```javascript
const obj = { x: 1 };
// Grabs obj.x as as { otherName }
const { x: otherName } = obj;
console.log(otherName) // 1
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What is destructuring assignment</h2>

The destructuring assignment is a JavaScript expression that makes it possible to unpack values from arrays or properties from objects into distinct variables.
Let's get the month values from an array using destructuring assignment

```javascript
var [one, two, three] = ["JAN", "FEB", "MARCH"];

console.log(one); // "JAN"
console.log(two); // "FEB"
console.log(three); // "MARCH"
```

and you can get user properties of an object using destructuring assignment,

```javascript
var { name, age } = { name: "John", age: 32 };

console.log(name); // John
console.log(age); // 32
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>What are default values in destructuring assignment</h2>

A variable can be assigned a default value when the value unpacked from the array or object is undefined during destructuring assignment. It helps to avoid setting default values separately for each assignment. Let's take an example for both arrays and object use cases,

**Arrays destructuring:**

```javascript
var x, y, z;

[x = 2, y = 4, z = 6] = [10];
console.log(x); // 10
console.log(y); // 4
console.log(z); // 6
```

**Objects destructuring:**

```javascript
var { x = 2, y = 4, z = 6 } = { x: 10 };

console.log(x); // 10
console.log(y); // 4
console.log(z); // 6
```

**[⬆ Back to Top](#table-of-contents)**

### <h2>How do you swap variables in destructuring assignment</h2>

If you don't use destructuring assignment, swapping two values requires a temporary variable. Whereas using a destructuring feature, two variable values can be swapped in one destructuring expression. Let's swap two number variables in array destructuring assignment,

```javascript
var x = 10,
y = 20;

[x, y] = [y, x];
console.log(x); // 20
console.log(y); // 10
```

**[⬆ Back to Top](#table-of-contents)**


<h2><a href="https://github.com/sanjay9616/JavaScript/blob/master/JavaScript-Tutorial/README.md"> 🔙 Back</a></h2>
